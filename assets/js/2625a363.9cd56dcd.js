"use strict";(self.webpackChunkmy_ibax=self.webpackChunkmy_ibax||[]).push([[29],{1618:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>c,toc:()=>o});var r=t(4848),s=t(8453);const i={},l="Compiler and Virtual Machine {#compiler-and-virtual-machine}",c={id:"topics/vm",title:"Compiler and Virtual Machine",description:"compiler-and-virtual-machine}",source:"@site/docs/topics/vm.md",sourceDirName:"topics",slug:"/topics/vm",permalink:"/docs/topics/vm",draft:!1,unlisted:!1,editUrl:"https://github.com/IBAX-io/docs/edit/main/docs/topics/vm.md",tags:[],version:"current",frontMatter:{},sidebar:"topicsSidebar",previous:{title:"Template Language",permalink:"/docs/topics/templates2"}},a={},o=[{value:"Source code storage and compilation",id:"source-code-storage-and-compilation",level:2},{value:"Virtual machine structures",id:"virtual-machine-structures",level:2},{value:"VM Structure",id:"vm-structure",level:3},{value:"Block structure",id:"block-structure",level:3},{value:"ObjInfo structure",id:"objinfo-structure",level:3},{value:"ContractInfo structure",id:"contractinfo-structure",level:4},{value:"FieldInfo structure",id:"fieldinfo-structure",level:4},{value:"FuncInfo structure",id:"funcinfo-structure",level:4},{value:"FuncName Structure",id:"funcname-structure",level:4},{value:"ExtFuncInfo structure",id:"extfuncinfo-structure",level:4},{value:"VarInfo structure",id:"varinfo-structure",level:4},{value:"ObjExtend value",id:"objextend-value",level:4},{value:"Virtual machine commands",id:"virtual-machine-commands",level:2},{value:"ByteCode structure",id:"bytecode-structure",level:3},{value:"Command identifiers",id:"command-identifiers",level:3},{value:"Stack operation commands",id:"stack-operation-commands",level:3},{value:"Runtime structure",id:"runtime-structure",level:3},{value:"blockStack structure",id:"blockstack-structure",level:4},{value:"RunCode function",id:"runcode-function",level:3},{value:"Other functions for operations with VM",id:"other-functions-for-operations-with-vm",level:3},{value:"Compiler",id:"compiler",level:2},{value:"Lexical analyzer",id:"lexical-analyzer",level:2},{value:"lextable/lextable.go",id:"lextable-lextable-go",level:3},{value:"lex-go",id:"lex-go",level:3},{value:"Needle language",id:"needle-language",level:2},{value:"Lexemes",id:"lexemes",level:3},{value:"Types",id:"types",level:3},{value:"Expressions",id:"expressions",level:3},{value:"Scope",id:"scope",level:3},{value:"Contract execution",id:"contract-execution",level:3},{value:"Backus\u2013Naur Form (BNF)",id:"backus-naur-form-bnf",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"compiler-and-virtual-machine",children:"Compiler and Virtual Machine"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#source-code-storage-and-compilation",children:"Source code storage and compilation"})}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"#virtual-machine-structures",children:"Virtual machine structures"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#vm-structure",children:"VM Structure"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#block-structure",children:"Block structure"})}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"#objinfo-structure",children:"ObjInfo structure"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#contractinfo-structure",children:"ContractInfo structure"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#fieldinfo-structure",children:"FieldInfo structure"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#funcinfo-structure",children:"FuncInfo structure"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#funcname-structure",children:"FuncName Structure"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#extfuncinfo-structure",children:"ExtFuncInfo structure"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#varinfo-structure",children:"VarInfo structure"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#objextend-value",children:"ObjExtend value"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"#virtual-machine-commands",children:"Virtual machine commands"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#bytecode-structure",children:"ByteCode structure"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#command-identifiers",children:"Command identifiers"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#stack-operation-commands",children:"Stack operation commands"})}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"#runtime-structure",children:"Runtime structure"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#blockstack-structure",children:"blockStack structure"})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#runcode-function",children:"RunCode function"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#other-functions-for-operations-with-vm",children:"Other functions for operations with VM"})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#compiler",children:"Compiler"})}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"#lexical-analyzer",children:"Lexical analyzer"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#lextable-lextable-go",children:"lextable/lextable.go"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#lex-go",children:"lex.go"})}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"#needle-language",children:"Needle language"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#lexemes",children:"Lexemes"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#types",children:"Types"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#expressions",children:"Expressions"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#scope",children:"Scope"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#contract-execution",children:"Contract execution"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#backus-naur-form-bnf",children:"Backus\u2013Naur Form (BNF)"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This section involves program compilation and Needle language operations in the\nVirtual Machine (VM)."}),"\n",(0,r.jsx)(n.h2,{id:"source-code-storage-and-compilation",children:"Source code storage and compilation"}),"\n",(0,r.jsx)(n.p,{children:"Contracts and functions are written with Golang and stored in the contract\ntables of ecosystems."}),"\n",(0,r.jsx)(n.p,{children:"When a contract is executed, its source code will be read from the database and\ncompiled into bytecode."}),"\n",(0,r.jsx)(n.p,{children:"When a contract is changed, its source code will be updated and saved in the\ndatabase. Then, the source code is compiled, thereby updating the bytecode in\nthe corresponding virtual machine."}),"\n",(0,r.jsx)(n.p,{children:"As bytecodes are not physically saved, it will be compiled anew when the program\nis executed again."}),"\n",(0,r.jsx)(n.p,{children:"The entire source code described in the contract table of each ecosystem is\ncompiled into a virtual machine in strict order, and the status of the virtual\nmachine is the same on all nodes."}),"\n",(0,r.jsx)(n.p,{children:"When the contract is called, the virtual machine will not change its status in\nany way. The execution of any contract or calling of any function occurs on a\nseparate running stack created during each external call."}),"\n",(0,r.jsx)(n.p,{children:"Each ecosystem can have a so-called virtual ecosystem, which can be used within\na node in conjunction with tables outside the blockchain, without direct\naffection on the blockchain or other virtual ecosystems. In this case, the node\nhosting such a virtual ecosystem will compile its contract and create its own\nvirtual machine."}),"\n",(0,r.jsx)(n.h2,{id:"virtual-machine-structures",children:"Virtual machine structures"}),"\n",(0,r.jsx)(n.h3,{id:"vm-structure",children:"VM Structure"}),"\n",(0,r.jsx)(n.p,{children:"A virtual machine is organized in memory as a structure like below."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"type VM struct {\n   Block\n   ExtCost func(string) int64\n   FuncCallsDB map[string]struct{}\n   Extern bool\n   ShiftContract int64\n   logger *log.Entry\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"A VM structure has the following elements:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Block - contains a ",(0,r.jsx)(n.a,{href:"#block-structure",children:"block structure"}),";"]}),"\n",(0,r.jsx)(n.li,{children:"ExtCost - a function returns the cost of executing an external golang\nfunction;"}),"\n",(0,r.jsx)(n.li,{children:"FuncCallsDB - a collection of Golang function names. This function returns the\nexecution cost as the first parameter. These functions use EXPLAIN to\ncalculate the cost of database processing;"}),"\n",(0,r.jsx)(n.li,{children:"Extern - a Boolean flag indicating whether a contract is an external contract.\nIt is set to true when a VM is created. Contracts called are not displayed\nwhen the code is compiled. In other words, it allows to call the contract code\ndetermined in the future;"}),"\n",(0,r.jsx)(n.li,{children:"ShiftContract - ID of the first contract in the VM;"}),"\n",(0,r.jsx)(n.li,{children:"logger - VM error log output."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"block-structure",children:"Block structure"}),"\n",(0,r.jsxs)(n.p,{children:["A virtual machine is a tree composed of ",(0,r.jsx)(n.strong,{children:"Block type"})," objects."]}),"\n",(0,r.jsxs)(n.p,{children:["A block is an independent unit that contains some bytecodes. In simple terms,\neverything you put in the braces (",(0,r.jsx)(n.code,{children:"{}"}),") in the language is a block."]}),"\n",(0,r.jsx)(n.p,{children:"For example, the following code would create a block with functions. This block\nalso contains another block with an if statement, which contains a block with a\nwhile statement."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"func my() {\n   if true {\n      while false {\n      ...\n      }\n   }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"The block is organized in the memory as a structure like below."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"type Block struct {\n   Objects map[string]*ObjInfo\n   Type int\n   Owner *OwnerInfo\n   Info interface{}\n   Parent *Block\n   Vars []reflect.Type\n   Code ByteCodes\n   Children Blocks\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"A block structure consists of the following elements:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Objects"})," - a map of internal objects of the pointer type\n",(0,r.jsx)(n.a,{href:"#objinfo-structure",children:"ObjInfo"}),". For example, if there is a variable in the\nblock, you can get information about it by its name;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type"})," - the type of the block. For a function block, its type is\n",(0,r.jsx)(n.strong,{children:"ObjFunc"}),"; for a contract block, its type is ",(0,r.jsx)(n.strong,{children:"ObjContract"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Owner"})," - a structure of ",(0,r.jsx)(n.strong,{children:"OwnerInfo"})," pointer type. This structure contains\ninformation about the owner of the compiled contract, which is specified\nduring contract compilation or obtained from the ",(0,r.jsx)(n.strong,{children:"contracts"})," table;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Info"})," - it contains information about the object, which depends on the\nblock type;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Parent"})," - a pointer to the parent block;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Vars"})," - an array containing the types of current block variables;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Code"})," - the bytecode of the block itself, which will be executed when the\ncontrol rights are passed to the block, for example, function calls or loop\nbodies;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Children"})," - an array containing sub-blocks, such as function nesting,\nloops, conditional operators."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"objinfo-structure",children:"ObjInfo structure"}),"\n",(0,r.jsx)(n.p,{children:"The ObjInfo structure contains information about internal objects."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"type ObjInfo struct {\n   Type int\n   Value interface{}\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"The ObjInfo structure has the following elements:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Type"})," is the object type, which has any of the following values:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ObjContract"})," \u2013 ",(0,r.jsx)(n.a,{href:"#contractinfo-structure",children:"contract"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ObjFunc"})," - function;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ObjExtFunc"})," - external golang function;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ObjVar"})," - variable;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ObjExtend"})," - $name variable."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Value"})," \u2013 it contains the structure of each type."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"contractinfo-structure",children:"ContractInfo structure"}),"\n",(0,r.jsxs)(n.p,{children:["Pointing to the ",(0,r.jsx)(n.strong,{children:"ObjContract"})," type, and the ",(0,r.jsx)(n.strong,{children:"Value"})," field contains a\n",(0,r.jsx)(n.strong,{children:"ContractInfo"})," structure."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"type ContractInfo struct {\n   ID uint32\n   Name string\n   Owner *OwnerInfo\n   Used map[string]bool\n   Tx *[]*FieldInfo\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"The ContractInfo structure has the following elements:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ID"})," - contract ID, displayed in the blockchain when calling the contract;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Name"})," - contract name;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Owner"})," - other information about the contract;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Used"})," - map of contracts names that has been called;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Tx"})," - a data array described in the ",(0,r.jsx)(n.a,{href:"/docs/topics/script#data-section",children:"data section"}),"\nof the contract."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"fieldinfo-structure",children:"FieldInfo structure"}),"\n",(0,r.jsxs)(n.p,{children:["The FieldInfo structure is used in the ",(0,r.jsx)(n.strong,{children:"ContractInfo"})," structure and describes\nelements in ",(0,r.jsx)(n.a,{href:"/docs/topics/script#data-section",children:"data section"})," of a contract."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"type FieldInfo struct {\n   Name string\n   Type reflect.Type\n   Original uint32\n   Tags string\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"The FieldInfo structure has the following elements:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Name"})," - field name;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type"})," - field type;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Original"})," - optional field;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Tags"})," - additional labels for this field."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"funcinfo-structure",children:"FuncInfo structure"}),"\n",(0,r.jsx)(n.p,{children:"Pointing to the ObjFunc type, and the Value field contains a FuncInfo structure."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"type FuncInfo struct {\n   Params []reflect.Type\n   Results []reflect.Type\n   Names *map[string]FuncName\n   Variadic bool\n   ID uint32\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"The FuncInfo structure has the following elements:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Params"})," - an array of parameter types;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Results"})," - an array of returned types;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Names"})," - map of data for tail functions, for example,\n",(0,r.jsx)(n.code,{children:"DBFind().Columns ()"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Variadic"})," - true if the function can have a variable number of parameters;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ID"})," - function ID."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"funcname-structure",children:"FuncName Structure"}),"\n",(0,r.jsx)(n.p,{children:"The FuncName structure is used for FuncInfo and describes the data of a tail\nfunction."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"type FuncName struct {\n   Params []reflect.Type\n   Offset []int\n   Variadic bool\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"The FuncName structure has the following elements:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Params"})," - an array of parameter types;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Offset"})," - the array of offsets for these variables. In fact, the values of\nall parameters in a function can be initialized with the dot .;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Variadic"})," - true if the tail function can have a variable number of\nparameters."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"extfuncinfo-structure",children:"ExtFuncInfo structure"}),"\n",(0,r.jsx)(n.p,{children:"Pointing to the ObjExtFunc type, and the Value field contains a ExtFuncInfo\nstructure. It is used to describe golang functions."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"type ExtFuncInfo struct {\n   Name string\n   Params []reflect.Type\n   Results []reflect.Type\n   Auto []string\n   Variadic bool\n   Func interface{}\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"The ExtFuncInfo structure has the following elements:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Name"}),", ",(0,r.jsx)(n.strong,{children:"Params"}),", ",(0,r.jsx)(n.strong,{children:"Results"})," parameters have the same structure as\n",(0,r.jsx)(n.a,{href:"#funcinfo-structure",children:"FuncInfo"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Auto"})," - an array of variables. If any, passes to the function as an\nadditional parameter. For example, a variable of type SmartContract sc;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Func"})," - golang functions."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"varinfo-structure",children:"VarInfo structure"}),"\n",(0,r.jsxs)(n.p,{children:["Pointing to the ",(0,r.jsx)(n.strong,{children:"ObjVar"})," type, and the ",(0,r.jsx)(n.strong,{children:"Value"})," field contains a ",(0,r.jsx)(n.strong,{children:"VarInfo"}),"\nstructure."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"type VarInfo struct {\n   Obj *ObjInfo\n   Owner *Block\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"The VarInfo structure has the following elements:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Obj"})," - information about the type and value of the variable;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Owner"})," - Pointer to the owner block."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"objextend-value",children:"ObjExtend value"}),"\n",(0,r.jsxs)(n.p,{children:["Pointing to the ",(0,r.jsx)(n.strong,{children:"ObjExtend"})," type, and the ",(0,r.jsx)(n.strong,{children:"Value"})," field contains a string\ncontaining the name of the variable or function."]}),"\n",(0,r.jsx)(n.h2,{id:"virtual-machine-commands",children:"Virtual machine commands"}),"\n",(0,r.jsx)(n.h3,{id:"bytecode-structure",children:"ByteCode structure"}),"\n",(0,r.jsxs)(n.p,{children:["A bytecode is a sequence of ",(0,r.jsx)(n.strong,{children:"ByteCode"})," type structures."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"type ByteCode struct {\n   Cmd uint16\n   Value interface{}\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"This structure has the following fields:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cmd"})," - the identifier of the storage commands;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Value"})," - contains the operand (value)."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"In general, commands perform an operation on the top element of the stack and\nwrites the result value into it if necessary."}),"\n",(0,r.jsx)(n.h3,{id:"command-identifiers",children:"Command identifiers"}),"\n",(0,r.jsx)(n.p,{children:"Identifiers of the virtual machine commands are described in the vm/cmds_list.go\nfile."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdPush"})," \u2013 put a value from the Value field to the stack. For example, put\nnumbers and lines to the stack;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdVar"})," - put the value of a variable to the stack. Value contains a\npointer to the VarInfo structure and information about the variable;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdExtend"})," \u2013 put the value of an external variable to the stack. Value\ncontains a string with the variable name (starting with $);"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdCallExtend"})," \u2013 call an external function (starting with ",(0,r.jsx)(n.code,{children:"$"}),"). The\nparameters of the function are obtained from the stack, and the results are\nplaced to the stack. Value contains a function name (starting with ",(0,r.jsx)(n.code,{children:"$"}),");"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdPushStr"})," \u2013 put the string in Value to the stack;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdCall"})," - calls the virtual machine function. Value contains a ",(0,r.jsx)(n.strong,{children:"ObjInfo"}),"\nstructure. This command is applicable to the ",(0,r.jsx)(n.strong,{children:"ObjExtFunc"})," golang function\nand ",(0,r.jsx)(n.strong,{children:"ObjFunc"})," Needle function. If a function is called, its parameters will\nbe obtained from the stack and the result values will be placed to the stack;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdCallVari"})," - similar to the ",(0,r.jsx)(n.strong,{children:"cmdCall"})," command, it calls the virtual\nmachine function. This command is used to call a function with a variable\nnumber of parameters;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdReturn"})," - used to exit the function. The return values will be put to\nthe stack, and the Value field is not used;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdIf"})," \u2013 transfer control to the bytecode in the ",(0,r.jsx)(n.strong,{children:"block"})," structure, which\nis passed in the Value field. The control will be transferred to the stack\nonly when the top element of the stack is called by the ",(0,r.jsx)(n.em,{children:"valueToBool"})," function\nand returned ",(0,r.jsx)(n.code,{children:"true"}),". Otherwise, the control will be transferred to the next\ncommand;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdElse"})," - this command works in the same way as the ",(0,r.jsx)(n.strong,{children:"cmdIf"}),", but only\nwhen the top element of the stack is called by the valueToBool function and\nreturned ",(0,r.jsx)(n.code,{children:"false"}),", the control will be transferred to the specified block;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdAssignVar"})," \u2013 get a list of variables of type ",(0,r.jsx)(n.strong,{children:"VarInfo"})," from Value.\nThese variables use the ",(0,r.jsx)(n.strong,{children:"cmdAssign"})," command to get the value;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdAssign"})," \u2013 assign the value in the stack to the variable obtained by the\n",(0,r.jsx)(n.strong,{children:"cmdAssignVar"})," command;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdLabel"})," - defines a label when control is returned during the while loop;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdContinue"})," - this command transfers control to the ",(0,r.jsx)(n.strong,{children:"cmdLabel"})," label.\nWhen executing a new iteration of the loop, Value is not used;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdWhile"})," \u2013 use valueToBool to check the top element of the stack. If this\nvalue is ",(0,r.jsx)(n.code,{children:"true"}),", the ",(0,r.jsx)(n.strong,{children:"block"})," structure will be called from the value field;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdBreak"})," - exits the loop;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdIndex"})," \u2013 put the value in map or array into the stack by index, without\nusing Value. For example,\n",(0,r.jsx)(n.code,{children:"(map | array) (index value) => (map | array [index value])"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdSetIndex"})," \u2013 assigns the value of the top element of the stack to\nelements of map or array, without using Value. For example,\n",(0,r.jsx)(n.code,{children:"(map | array) (index value) (value) => (map | array)"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdFuncName"})," - adds parameters that are passed using sequential\ndescriptions divided by dot . For example,\n",(0,r.jsx)(n.code,{children:"func name => Func (...) .Name (...)"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdUnwrapArr"})," - defines a Boolean flag if the top element of the stack is\nan array;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdMapInit"})," \u2013 initializes the value of map;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdArrayInit"})," \u2013 initializes the value of array;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdError"})," - this command is created when a contract or function terminates\nwith a specified ",(0,r.jsx)(n.code,{children:"error, warning, info"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"stack-operation-commands",children:"Stack operation commands"}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsxs)(n.p,{children:["In the current version, automatic type conversion is not fully applicable for\nthese commands. see ",(0,r.jsx)(n.a,{href:"/docs/needle/spec#spec-operator",children:"Operator"}),"."]})}),"\n",(0,r.jsx)(n.p,{children:"The following are commands for direct stack processing. The Value field is not\nused in these commands."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdNot"})," - logical negation. ",(0,r.jsx)(n.code,{children:"(val) => (!ValueToBool(val))"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdSign"})," - change of sign. ",(0,r.jsx)(n.code,{children:"(val) => (-val)"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdAdd"})," - addition. ",(0,r.jsx)(n.code,{children:"(val1)(val2) => (val1 + val2)"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdSub"})," - subtraction. ",(0,r.jsx)(n.code,{children:"(val1)(val2) => (val1-val2)"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdMul"})," - multiplication. ",(0,r.jsx)(n.code,{children:"(val1)(val2) => (val1 * val2)"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdDiv"})," - division. ",(0,r.jsx)(n.code,{children:"(val1)(val2) => (val1 / val2)"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdAnd"})," - logical AND.\n",(0,r.jsx)(n.code,{children:"(val1)(val2) => (valueToBool(val1) && valueToBool(val2))"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdOr"})," - logical OR.\n",(0,r.jsx)(n.code,{children:"(val1)(val2) => (valueToBool(val1) || valueToBool(val2))"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdEqual"})," - equality comparison, bool is returned.\n",(0,r.jsx)(n.code,{children:"(val1)(val2) => (val1 == val2)"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdNotEq"})," - inequality comparison, bool is returned.\n",(0,r.jsx)(n.code,{children:"(val1)(val2) => (val1 != val2)"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdLess"})," - less-than comparison, bool is returned.\n",(0,r.jsx)(n.code,{children:"(val1)(val2) => (val1 <val2)"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdNotLess"})," - greater-than-or-equal comparison, bool is returned.\n",(0,r.jsx)(n.code,{children:"(val1)(val2) => (val1 >= val2)"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdGreat"})," - greater-than comparison, bool is returned.\n",(0,r.jsx)(n.code,{children:"(val1)(val2) => (val1> val2)"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdNotGreat"})," - less-than-or-equal comparison, bool is returned.\n",(0,r.jsx)(n.code,{children:"(val1)(val2) => (val1 <= val2)"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"runtime-structure",children:"Runtime structure"}),"\n",(0,r.jsx)(n.p,{children:"The execution of bytecodes will not affect the virtual machine. For example, it\nallows various functions and contracts to run simultaneously in a single virtual\nmachine. The Runtime structure is used to run functions and contracts, as well\nas any expressions and bytecode."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"type RunTime struct {\n   stack []interface{}\n   blocks []*blockStack\n   vars []interface{}\n   extend *map[string]interface{}\n   vm *VM\n   cost int64\n   err error\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"stack"})," - the stack to execute the bytecode;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"blocks"})," - block calls stack;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"vars"})," - stack of variables. Its variable will be added to the stack of\nvariables when the bytecode is called in the block. After exiting the block,\nthe size of the stack of variables will return to the previous value;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"extend"})," - a pointer to map with values of external variables (",(0,r.jsx)(n.code,{children:"$name"}),");"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"vm"})," - a virtual machine pointer;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cost"})," - fuel unit of the resulting cost of execution;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"err"})," - error occurred during execution."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"blockstack-structure",children:"blockStack structure"}),"\n",(0,r.jsx)(n.p,{children:"The blockStack structure is used in the Runtime structure."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"type blockStack struct {\n   Block *Block\n   Offset int\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Block"})," - a pointer to the block being executed;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Offset"})," \u2013 the offset of the last command executed in the bytecode of the\nspecified block."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"runcode-function",children:"RunCode function"}),"\n",(0,r.jsxs)(n.p,{children:["Bytecodes are executed in the ",(0,r.jsx)(n.strong,{children:"RunCode"})," function. It contains a loop that\nperforms the corresponding operation for each bytecode command. Before\nprocessing a bytecode, the data required must be initialized."]}),"\n",(0,r.jsx)(n.p,{children:"New blocks are added to other blocks."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"rt.blocks = append(rt.blocks, &blockStack{block, len(rt.vars)})\n"})}),"\n",(0,r.jsx)(n.p,{children:"Next, get the information of relevant parameters of the tail function. These\nparameters are contained in the last element of the stack."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"var namemap map[string][]interface{}\nif block.Type == ObjFunc && block.Info.(*FuncInfo).Names != nil {\n   if rt.stack[len(rt.stack)-1] != nil {\n      namemap = rt.stack[len(rt.stack)-1].(map[string][]interface{})\n   }\n   rt.stack = rt.stack[:len(rt.stack)-1]\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Then, all variables defined in the current block must be initialized with their\ninitial values."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"start := len(rt.stack)\nvaroff := len(rt.vars)\nfor vkey, vpar := range block.Vars {\n   rt.cost--\n   var value interface{}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Since variables in the function are also variables, we need to retrieve them\nfrom the last element of the stack in the order described by the function\nitself."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"   if block.Type == ObjFunc && vkey <len(block.Info.(*FuncInfo).Params) {\n      value = rt.stack[start-len(block.Info.(*FuncInfo).Params)+vkey]\n   } else {\n"})}),"\n",(0,r.jsx)(n.p,{children:"Initialize local variables with their initial values."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"      value = reflect.New(vpar).Elem().Interface()\n\n      if vpar == reflect.TypeOf(map[string]interface{}{}) {\n\n         value = make(map[string]interface{})\n      } else if vpar == reflect.TypeOf([]interface{}{}) {\n         value = make([]interface{}, 0, len(rt.vars)+1)\n      }\n   }\n   rt.vars = append(rt.vars, value)\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Next, update the values of variable parameters passed in the tail function."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"if namemap != nil {\n   for key, item := range namemap {\n      params := (*block.Info.(*FuncInfo).Names)[key]\n      for i, value := range item {\n         if params.Variadic && i >= len(params.Params)-1 {\n"})}),"\n",(0,r.jsx)(n.p,{children:"If variable parameters passed belongs to a variable number of parameters, then\nthese parameters will be combined into an array of variables."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"            off := varoff + params.Offset[len(params.Params)-1]\n            rt.vars[off] = append(rt.vars[off].([]interface{}), value)\n         } else {\n            rt.vars[varoff+params.Offset[i]] = value\n         }\n      }\n   }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"After that, all we have to do is delete values passed from the top of the stack\nas function parameters, thereby moving the stack. We have copied their values\ninto a variable array."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"if block.Type == ObjFunc {\n   start -= len(block.Info.(*FuncInfo).Params)\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"When a bytecode command loop finished, we must clear the stack correctly."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"last := rt.blocks[len(rt.blocks)-1]\n"})}),"\n",(0,r.jsx)(n.p,{children:"Delete the current block from the stack of blocks."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"rt.blocks = rt.blocks[:len(rt.blocks)-1]\nif status == statusReturn {\n"})}),"\n",(0,r.jsx)(n.p,{children:"If successfully exited from a function already executed, we will add the return\nvalue to the end of the previous stack."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"   if last.Block.Type == ObjFunc {\n      for count := len(last.Block.Info.(*FuncInfo).Results); count > 0; count-- {\n         rt.stack[start] = rt.stack[len(rt.stack)-count]\n         start++\n      }\n      status = statusNormal\n   } else {\n"})}),"\n",(0,r.jsx)(n.p,{children:"As you can see, if we do not execute the function, then we will not restore the\nstack status and exit the function as is. The reason is that loops and\nconditional structures that have been executed in the function are also bytecode\nblocks."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"   return\n\n   }\n}\n\nrt.stack = rt.stack[:start]\n"})}),"\n",(0,r.jsx)(n.h3,{id:"other-functions-for-operations-with-vm",children:"Other functions for operations with VM"}),"\n",(0,r.jsxs)(n.p,{children:["Your may create a virtual machine with the ",(0,r.jsx)(n.strong,{children:"NewVM"})," function. Each virtual\nmachine will be added with four functions, such as ",(0,r.jsx)(n.strong,{children:"ExecContract"}),",\n",(0,r.jsx)(n.strong,{children:"MemoryUsage"}),", ",(0,r.jsx)(n.strong,{children:"CallContract"}),", and ",(0,r.jsx)(n.strong,{children:"Settings"}),", through the ",(0,r.jsx)(n.strong,{children:"Extend"}),"\nfunction."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"for key, item := range ext.Objects {\n   fobj := reflect.ValueOf(item).Type()\n"})}),"\n",(0,r.jsx)(n.p,{children:"We traverse all the objects passed and only look at the functions."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"   switch fobj.Kind() {\n   case reflect.Func:\n"})}),"\n",(0,r.jsxs)(n.p,{children:["We fill the ",(0,r.jsx)(n.strong,{children:"ExtFuncInfo"})," structure according to the information received\nabout the function, and add its structure to the top level map ",(0,r.jsx)(n.strong,{children:"Objects"})," by\nname."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"   data := ExtFuncInfo{key, make([]reflect.Type, fobj.NumIn()), make([]reflect.Type, fobj.NumOut()),\n   make([]string, fobj.NumIn()), fobj.IsVariadic(), item}\n   for i := 0; i <fobj.NumIn(); i++ {\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"ExtFuncInfo"})," structure has an ",(0,r.jsx)(n.strong,{children:"Auto"})," parameter array. Usually the first\nparameter is ",(0,r.jsx)(n.code,{children:"sc *SmartContract"})," or ",(0,r.jsx)(n.code,{children:"rt *Runtime"}),", we cannot pass them from\ntheNeedle language, because they are necessary for us to execute some golang\nfunctions. Therefore, we specify that these variables will be used automatically\nwhen these functions are called. In this case, the first parameter of the above\nfour functions is ",(0,r.jsx)(n.code,{children:"rt *Runtime"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"   if isauto, ok := ext.AutoPars[fobj.In(i).String()]; ok {\n      data.Auto[i] = isauto\n   }\n"})}),"\n",(0,r.jsx)(n.p,{children:"Information about assigning the parameters."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"      data.Params[i] = fobj.In(i)\n   }\n"})}),"\n",(0,r.jsx)(n.p,{children:"And the types of return values."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"for i := 0; i <fobj.NumOut(); i++ {\n   data.Results[i] = fobj.Out(i)\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Adds a function to the root ",(0,r.jsx)(n.strong,{children:"Objects"})," so that the compiler can find them later\nwhen using the contract."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"      vm.Objects[key] = &ObjInfo{ObjExtFunc, data}\n   }\n\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"compiler",children:"Compiler"}),"\n",(0,r.jsx)(n.p,{children:"Functions in the compile.go file are responsible for compiling the array of\ntokens obtained from the lexical analyzer. Compilation can be divided into two\nlevels conditionally. At the top level, we deal with functions, contracts, code\nblocks, conditional and loop statements, variable definitions, and so on. At the\nlower level, we compile expressions in code blocks or conditions in loops and\nconditional statements."}),"\n",(0,r.jsxs)(n.p,{children:["First, we will start from the simple lower level. In the ",(0,r.jsx)(n.strong,{children:"compileEval"}),"\nfunction, expressions can be converted to bytecode. Since we use a virtual\nmachine with a stack, it is necessary to convert ordinary infix record\nexpressions into postfix notation or reverse Polish notation. For example, we\nconvert ",(0,r.jsx)(n.code,{children:"1+2"})," to ",(0,r.jsx)(n.code,{children:"12+"})," and put ",(0,r.jsx)(n.code,{children:"1"})," and ",(0,r.jsx)(n.code,{children:"2"})," to the stack. Then, we apply the\naddition operation to the last two elements in the stack and write the result to\nthe stack. You can find this\n",(0,r.jsx)(n.a,{href:"https://master.virmandy.net/perevod-iz-infiksnoy-notatsii-v-postfiksnuyu-obratnaya-polskaya-zapis/",children:"conversion"}),"\nalgorithm on the Internet."]}),"\n",(0,r.jsxs)(n.p,{children:["The global variable ",(0,r.jsx)(n.code,{children:"opers = map [uint32] operPrior"})," contains the priority of\noperations required for conversion to inverse Polish notation."]}),"\n",(0,r.jsxs)(n.p,{children:["The following variables are defined at the beginning of the ",(0,r.jsx)(n.strong,{children:"compileEval"}),"\nfunction:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"buffer"})," - temporary buffer for bytecode commands;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"bytecode"})," - final buffer of bytecode commands;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"parcount"})," - temporary buffer used to calculate parameters when calling a\nfunction;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"setIndex"})," - variables in the work process will be set to true when we\nassign map or array elements. For example, ",(0,r.jsx)(n.code,{children:'a["my"] = 10'}),". In this case, we\nneed to use the specified ",(0,r.jsx)(n.strong,{children:"cmdSetIndex"})," command."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"We get a token in a loop and process it accordingly. For example, expression\nparing will be stopped if braces are found. When moving the string, we check\nwhether the previous statement is an operation and whether it is inside the\nparentheses, otherwise it will exit the expression is parsed."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"case isRCurly, isLCurly:\n   i--\n   if prevLex == isComma || prevLex == lexOper {\n      return errEndExp\n   }\n   break main\ncase lexNewLine:\n   if i > 0 && ((*lexems)[i-1].Type == isComma || (*lexems)[i-1].Type == lexOper) {\n      continue main\n   }\n   for k := len(buffer) - 1; k >= 0; k-- {\n   if buffer[k].Cmd == cmdSys {\n      continue main\n   }\n}\nbreak main\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"In general, the algorithm itself corresponds to an algorithm for converting to\ninverse Polish notation. With the consideration of the calling of necessary\ncontracts, functions, and indexes, as well as other things not encountered\nduring parsing and options for parsing lexIdent type tokens, then, variables,\nfunctions or contracts with this name will be checked. If nothing is found and\nthis is not a function or contract call, then it will indicate an error."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"objInfo, tobj := vm.findObj(lexem.Value.(string), block)\nif objInfo == nil && (!vm.Extern || i> *ind || i >= len(*lexems)-2 || (*lexems)[i+1].Type != isLPar) {\n   return fmt.Errorf(`unknown identifier %s`, lexem.Value.(string))\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["We may encounter such a situation, and the contract call will be described\nlater. In this example, if no functions or variables with the same name are\nfound, then we think it is necessary to call a contract. In this compiled\nlanguage, there is no difference between contracts and function calls. But we\nneed to call the contract through the ",(0,r.jsx)(n.strong,{children:"ExecContract"})," function used in the\nbytecode."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"if objInfo.Type == ObjContract {\n   if objInfo.Value != nil {\n      objContract = objInfo.Value.(*Block)\n   }\n   objInfo, tobj = vm.findObj(`ExecContract`, block)\n   isContract = true\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["We record the number of variables so far in ",(0,r.jsx)(n.code,{children:"count"}),", which will also be written\nto the stack along with the number of function parameters. In each subsequent\ndetection of parameters, we only need to increase this number by one unit at the\nlast element of the stack."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"count := 0\nif (*lexems)[i+2].Type != isRPar {\n   count++\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["We have a list Used of called parameters for contracts, then we need to mark the\ncase of the contract is called. If the contract is called without parameters, we\nmust add two empty parameters to call ",(0,r.jsx)(n.strong,{children:"ExecContract"})," to get at least two\nparameters."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'if isContract {\n   name := StateName((*block)[0].Info.(uint32), lexem.Value.(string))\n   for j := len(*block) - 1; j >= 0; j-- {\n   topblock := (*block)[j]\n      if topblock.Type == ObjContract {\n         if topblock.Info.(*ContractInfo).Used == nil {\n            topblock.Info.(*ContractInfo).Used = make(map[string]bool)\n         }\n         topblock.Info.(*ContractInfo).Used[name] = true\n      }\n   }\n   bytecode = append(bytecode, &ByteCode{cmdPush, name})\n   if count == 0 {\n      count = 2\n      bytecode = append(bytecode, &ByteCode{cmdPush, ""})\n      bytecode = append(bytecode, &ByteCode{cmdPush, ""})\n   }\n   count++\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["If we see that there is a square bracket next, then we add the ",(0,r.jsx)(n.strong,{children:"cmdIndex"}),"\ncommand to get the value by the index."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"if (*lexems)[i+1].Type == isLBrack {\n   if objInfo == nil || objInfo.Type != ObjVar {\n      return fmt.Errorf(`unknown variable %s`, lexem.Value.(string))\n   }\n   buffer = append(buffer, &ByteCode{cmdIndex, 0})\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"CompileBlock"})," function can generate object trees and\nexpression-independent bytecodes. The compilation process is based on a finite\nstate machine, just like a lexical analyzer, but with the following differences.\nFirst, we do not use symbols but tokens; second, we will immediately describe\nthe ",(0,r.jsx)(n.em,{children:"states"})," variables in all states and transitions. It represents an array of\nobjects indexed by token type. Each token has a structure of ",(0,r.jsx)(n.em,{children:"compileState"}),", and\na new state is specified in ",(0,r.jsx)(n.em,{children:"NewState"}),". If it is clear what structure we have\nresolved, we can specify the function of the handler in the ",(0,r.jsx)(n.em,{children:"Func"})," field."]}),"\n",(0,r.jsx)(n.p,{children:"Let us review the main state as an example."}),"\n",(0,r.jsxs)(n.p,{children:["If we encounter a newline or comment, then we will remain in the same state. If\nwe encounter the ",(0,r.jsx)(n.strong,{children:"contract"})," keyword, then we change the state to\n",(0,r.jsx)(n.em,{children:"stateContract"})," and start parsing the structure. If we encounter the ",(0,r.jsx)(n.strong,{children:"func"}),"\nkeyword, then we change the state to ",(0,r.jsx)(n.em,{children:"stateFunc"}),". If other tokens are received,\nthe function generating error will be called."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"{// stateRoot\n   lexNewLine: {stateRoot, 0},\n   lexKeyword | (keyContract << 8): {stateContract | statePush, 0},\n   lexKeyword | (keyFunc << 8): {stateFunc | statePush, 0},\n   lexComment: {stateRoot, 0},\n   0: {errUnknownCmd, cfError},\n},\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Suppose we encountered the ",(0,r.jsx)(n.strong,{children:"func"})," keyword and we have changed the state to\n",(0,r.jsx)(n.em,{children:"stateFunc"}),". Since the function name must follow the ",(0,r.jsx)(n.strong,{children:"func"})," keyword, we will\nkeep the same state when changing the function name. For all other tokens, we\nwill generate corresponding errors. If we get the function name in the token\nidentifier, then we go to the ",(0,r.jsx)(n.em,{children:"stateFParams"})," state, where we can get the\nparameters of the function."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"{// stateFunc\n   lexNewLine: {stateFunc, 0},\n   lexIdent: {stateFParams, cfNameBlock},\n   0: {errMustName, cfError},\n},\n"})}),"\n",(0,r.jsxs)(n.p,{children:["At the same time as the above operations, we will call the ",(0,r.jsx)(n.strong,{children:"fNameBlock"}),"\nfunction. It should be noted that the Block structure is created with the\nstatePush mark, where we get it from the buffer and fill it with the data we\nneed. The ",(0,r.jsx)(n.strong,{children:"fNameBlock"})," function is suitable for contracts and functions\n(including those nested in them). It fills the ",(0,r.jsx)(n.em,{children:"Info"})," field with the\ncorresponding structure and writes itself into the ",(0,r.jsx)(n.em,{children:"Objects"})," of the parent\nblock. In this way, we can call the function or contract with the specified\nname. Similarly, we create corresponding functions for all states and variables.\nThese functions are usually very small and perform some duties when constructing\nthe virtual machine tree."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"func fNameBlock(buf *[]*Block, state int, lexem *Lexem) error {\n   var itype int\n   prev := (*buf)[len(*buf)-2]\n   fblock := (*buf)[len(*buf)-1]\n   name := lexem.Value.(string)\n   switch state {\n      case stateBlock:\n         itype = ObjContract\n         name = StateName((*buf)[0].Info.(uint32), name)\n         fblock.Info = &ContractInfo{ID: uint32(len(prev.Children) - 1), Name: name,\n         Owner: (*buf)[0].Owner}\n      default:\n         itype = ObjFunc\n         fblock.Info = &FuncInfo{}\n   }\n   fblock.Type = itype\n   prev.Objects[name] = &ObjInfo{Type: itype, Value: fblock}\n   return nil\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["For the ",(0,r.jsx)(n.strong,{children:"CompileBlock"})," function, it just traverses all the tokens and switches\nstates according to the tokens described in states. Almost all additional tokens\ncorrespond to additional program codes."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"statePush"})," \u2013 adds the ",(0,r.jsx)(n.strong,{children:"Block"})," object to the object tree;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"statePop"})," - used when the block ends with a closing brace;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"stateStay"})," - you need to keep the current mark when changing to a new\nstate;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"stateToBlock"})," - transition to the ",(0,r.jsx)(n.strong,{children:"stateBlock"})," state for processing\n",(0,r.jsx)(n.em,{children:"while"})," and ",(0,r.jsx)(n.em,{children:"if"}),". After processing expressions, you need to process blocks\nwithin the braces;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"stateToBody"})," - transition to the ",(0,r.jsx)(n.strong,{children:"stateBody"})," state;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"stateFork"})," - save the marked position. When the expression starts with an\nidentifier or a name with ",(0,r.jsx)(n.code,{children:"$"}),", we can make function calls or assignments;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"stateToFork"})," \u2013 used to get the token stored in ",(0,r.jsx)(n.strong,{children:"stateFork"}),", which will be\npassed to the process function;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"stateLabel"})," \u2013 used to insert ",(0,r.jsx)(n.strong,{children:"cmdLabel"})," commands. ",(0,r.jsx)(n.em,{children:"while"})," structure\nrequires this flag;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"stateMustEval"})," \u2013 check the availability of conditional expressions at the\nbeginning of ",(0,r.jsx)(n.em,{children:"if"})," and ",(0,r.jsx)(n.em,{children:"while"})," structures."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["In addition to the ",(0,r.jsx)(n.strong,{children:"CompileBlock"})," function, the ",(0,r.jsx)(n.strong,{children:"FlushBlock"})," function should\nalso be mentioned. But the problem is that the block tree is constructed\nindependently of existing virtual machines. More precisely, we obtain\ninformation about functions and contracts that exist in a virtual machine, but\nwe collect the compiled blocks into a separate tree. Otherwise, if an error\noccurs during compilation, we must roll back the virtual machine to the previous\nstate. Therefore, we go to the compilation tree separately, but after the\ncompilation is successful, the ",(0,r.jsx)(n.strong,{children:"FlushContract"})," function must be called. This\nfunction adds the completed block tree to the current virtual machine. The\ncompilation phase is now complete."]}),"\n",(0,r.jsx)(n.h2,{id:"lexical-analyzer",children:"Lexical analyzer"}),"\n",(0,r.jsx)(n.p,{children:"The lexical analyzer processes incoming strings and forms a sequence of tokens\nof the following types :"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexSys"})," - system token, for example: ",(0,r.jsx)(n.code,{children:"{}, [], (), ,, ."})," etc;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexOper"})," - operation token, for example: ",(0,r.jsx)(n.code,{children:"+, -, /, \\, *"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexNumber"})," - number;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexident"})," - identifier;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexNewline"})," - newline character;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexString"})," - string;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexComment"})," - comment;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexKeyword"})," - keyword;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexType"})," - type;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexExtend"})," - reference to external variables or functions, for example:\n",(0,r.jsx)(n.code,{children:"$myname"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["In the current version, a conversion table (finite state machine) is initially\nconstructed with the help of the ",(0,r.jsx)(n.a,{href:"#lextable-lextable-go",children:"lextable.go"})," file to\nparse the tokens, which is written to the lex_table.go file. In general, you can\nget rid of the conversion table initially generated by the file and create a\nconversion table in the memory (",(0,r.jsx)(n.code,{children:"init()"}),") immediately upon startup. The lexical\nanalysis itself occurs in the lexParser function in the ",(0,r.jsx)(n.a,{href:"#lex-go",children:"lex.go"})," file."]}),"\n",(0,r.jsx)(n.h3,{id:"lextable-lextable-go",children:"lextable/lextable.go"}),"\n",(0,r.jsx)(n.p,{children:"Here we define the alphabet to operate and describe how the finite state machine\nchanges from one state to another based on the next received symbol."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"states"})," is a JSON object containing a list of states."]}),"\n",(0,r.jsxs)(n.p,{children:["Except for specific symbols, ",(0,r.jsx)(n.code,{children:"d"})," stands for all symbols not specified in the\nstate. ",(0,r.jsx)(n.code,{children:"n"})," stands for 0x0a, ",(0,r.jsx)(n.code,{children:"s"})," stands for space, ",(0,r.jsx)(n.code,{children:"q"})," stands for backquote, ",(0,r.jsx)(n.code,{children:"Q"}),"\nstands for double quote, ",(0,r.jsx)(n.code,{children:"r"})," stands for character >= 128, ",(0,r.jsx)(n.code,{children:"a"})," stands for AZ and\naz, and ",(0,r.jsx)(n.code,{children:"1"})," stands for 1- 9."]}),"\n",(0,r.jsx)(n.p,{children:"The name of these states are keys, and the possible values are listed in the\nvalue object. Then, there is a new state to make transitions for each group.\nThen there is the name of the token. If we need to return to the initial state,\nthe third parameter is the service token, which indicates how to handle the\ncurrent symbol."}),"\n",(0,r.jsxs)(n.p,{children:["For example, we have the main state and the incoming characters ",(0,r.jsx)(n.code,{children:"/"}),",\n",(0,r.jsx)(n.code,{children:'"/": ["solidus", "", "push next"]'}),","]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"push"})," - gives the command to remember that it is in a separate stack ;"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"next"})," - goes to the next character, and at the same time we change the\nstatus to ",(0,r.jsx)(n.strong,{children:"solidus"}),". After that, gets the next character and check the\nstatus of ",(0,r.jsx)(n.strong,{children:"solidus"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["If the next character has ",(0,r.jsx)(n.code,{children:"/"})," or ",(0,r.jsx)(n.code,{children:"/*"}),", then we go to the comment ",(0,r.jsx)(n.strong,{children:"comment"}),"\nstate because they start with ",(0,r.jsx)(n.code,{children:"//"})," or ",(0,r.jsx)(n.code,{children:"/*"}),". Obviously, each comment has a\ndifferent state afterwards, because they end with a different symbol."]}),"\n",(0,r.jsxs)(n.p,{children:["If the next character is not ",(0,r.jsx)(n.code,{children:"/"})," and ",(0,r.jsx)(n.code,{children:"*"}),", then we record everything in the stack\nas ",(0,r.jsx)(n.strong,{children:"lexOper"})," type tags, clear the stack and return to the main state."]}),"\n",(0,r.jsxs)(n.p,{children:["The following module converts the state tree into a numeric array and writes it\ninto the ",(0,r.jsx)(n.em,{children:"lex_table.go"})," file."]}),"\n",(0,r.jsx)(n.p,{children:"In the first loop:"}),"\n",(0,r.jsx)(n.p,{children:"We form an alphabet of valid symbols."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"for ind, ch := range alphabet {\n   i := byte(ind)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In addition, in ",(0,r.jsx)(n.strong,{children:"state2int"}),", we provide each state with its own sequence\nidentifier."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"   state2int := map[string]uint{`main`: 0}\n   if err := json.Unmarshal([]byte(states), &data); err == nil {\n   for key := range data {\n   if key != `main` {\n   state2int[key] = uint(len(state2int))\n"})}),"\n",(0,r.jsxs)(n.p,{children:["When we traverse all states and each set in a state and each symbol in a set, we\nwrite a three-byte number [new state identifier (0 = main)] + [token type ( 0-no\ntoken)] + [token]. The bidimensionality of the ",(0,r.jsx)(n.em,{children:"table"})," array is that it is\ndivided into states and 34 input symbols from the ",(0,r.jsx)(n.em,{children:"alphabet"})," array, which are\narranged in the same order."]}),"\n",(0,r.jsxs)(n.p,{children:["We are in the ",(0,r.jsx)(n.em,{children:"main"})," state on the zero row of the ",(0,r.jsx)(n.em,{children:"table"}),". Take the first\ncharacter, find its index in the ",(0,r.jsx)(n.em,{children:"alphabet"})," array, and get the value from the\ncolumn with the given index. Starting from the value received, we receive the\ntoken in the low byte. If the parsing is complete, the second byte indicates the\ntype of token received. In the third byte, we receive the index of the next new\nstate. All of these are described in more detail in the ",(0,r.jsx)(n.strong,{children:"lexParser"})," function\nin ",(0,r.jsx)(n.em,{children:"lex.go"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["If you want to add some new characters, you need to add them to the ",(0,r.jsx)(n.em,{children:"alphabet"}),"\narray and increase the quantity of the ",(0,r.jsx)(n.em,{children:"AlphaSize"})," constant. If you want to add\na new symbol combination, it should be described in the status, similar to the\nexisting options. After the above operation, run the ",(0,r.jsx)(n.em,{children:"lextable.go"})," file to\nupdate the ",(0,r.jsx)(n.em,{children:"lex_table.go"})," file."]}),"\n",(0,r.jsx)(n.h3,{id:"lex-go",children:"lex-go"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"lexParser"})," function directly generates lexical analysis and returns an\narray of received tags based on incoming strings. Let us analyze the structure\nof tokens."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"type Lexem struct {\n   Type  uint32 // Type of the lexem\n   Value interface{} // Value of lexem\n   Line  uint32 // Line of the lexem\n   Column uint32 // Position inside the line\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Type"})," - token type. It has one of the following values:\n",(0,r.jsx)(n.code,{children:"lexSys, lexOper, lexNumber, lexIdent, lexString, lexComment, lexKeyword, lexType, lexExtend"}),";"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Value"})," \u2013 token value. The type of value depends on the token type, Let us\nanalyze it in more detail:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexSys"})," - includes brackets, commas, etc. In this case,\n",(0,r.jsx)(n.code,{children:"Type = ch << 8 | lexSys"}),", please refer to the ",(0,r.jsx)(n.code,{children:"isLPar ... isRBrack"}),"\nconstant, and its value is uint32 bits;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexOper"})," - the value represents an equivalent character sequence in the\nform of uint32. See the ",(0,r.jsx)(n.code,{children:"isNot ... isOr"})," constants;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexNumber"})," - numbers are stored as int64 or float64. If the number has a\ndecimal point, it is float64;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexIdent"})," - identifiers are stored as string;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexNewLine"})," - newline character. Also used to calculate the row and token\nposition;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexString"})," - lines are stored as string;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexComment"})," - comments are stored as string;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexKeyword"})," - for keywords, only the corresponding indexes are stored,\nsee the ",(0,r.jsx)(n.code,{children:"keyContract ... keyTail"})," constant. In this case\n",(0,r.jsx)(n.code,{children:"Type = KeyID << 8 | lexKeyword"}),". In addition, it should be noted that the\n",(0,r.jsx)(n.code,{children:"true, false, nil"})," keywords will be immediately converted to lexNumber type\ntokens, and the corresponding ",(0,r.jsx)(n.code,{children:"bool"})," and ",(0,r.jsx)(n.code,{children:"intreface {}"})," types will be used;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexType"})," \u2013 this value contains the corresponding ",(0,r.jsx)(n.code,{children:"reflect.Type"})," type\nvalue;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexExtend"})," \u2013 identifiers beginning with a ",(0,r.jsx)(n.code,{children:"$"}),". These variables and\nfunctions are passed from the outside and are therefore assigned to special\ntypes of tokens. This value contains the name as a string without a $ at the\nbeginning."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Line"})," - the line where the token is found;"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Column"})," - in-line position of the token."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Let us analyze the ",(0,r.jsx)(n.strong,{children:"lexParser"})," function in detail. The ",(0,r.jsx)(n.strong,{children:"todo"})," function looks\nup the symbol index in the alphabet based on the current state and the incoming\nsymbol, and obtains a new state, token identifier (if any), and other tokens\nfrom the conversion table. The parsing itself involves calling the ",(0,r.jsx)(n.strong,{children:"todo"}),"\nfunction in turn for each next character and switching to a new state. Once the\ntag is received, we create the corresponding token in the output criteria and\ncontinue the parsing process. It should be noted that during the parsing\nprocess, we do not accumulate the token symbols into a separate stack or array,\nbecause we only save the offset of the start of the token. After getting the\ntoken, we move the offset of the next token to the current parsing position."]}),"\n",(0,r.jsx)(n.p,{children:"All that remains is to check the lexical status tokens used in the parsing:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexfPush"})," - this token means that we start to accumulate symbols in a new\ntoken;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexfNext"})," - the character must be added to the current token;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexfPop"})," - the receipt of the token is complete. Usually, with this flag we\nhave the identifier type of the parsed token;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexfSkip"}),' - this token is used to exclude characters from parsing. For\nexample, the control slashes in the string are \\n \\r ". They will be\nautomatically replaced during the lexical analysis stage.']}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"needle-language",children:"Needle language"}),"\n",(0,r.jsx)(n.h3,{id:"lexemes",children:"Lexemes"}),"\n",(0,r.jsx)(n.p,{children:"The source code of a program must be in UTF-8 encoding."}),"\n",(0,r.jsx)(n.p,{children:"The following lexical types are processed:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Keywords"})," -\n",(0,r.jsx)(n.code,{children:"action, break, conditions, continue, contract, data, else, error, false, func, If, info, nil, return, settings, true, var, warning, while"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Number"})," - only decimal numbers are accepted. There are two basic types:\n",(0,r.jsx)(n.strong,{children:"int"})," and ",(0,r.jsx)(n.strong,{children:"float"}),". If the number has a decimal point, it becomes a float\n",(0,r.jsx)(n.strong,{children:"float"}),". ",(0,r.jsx)(n.strong,{children:"int"})," type is equivalent to ",(0,r.jsx)(n.strong,{children:"int64"})," in golang, while ",(0,r.jsx)(n.strong,{children:"float"}),"\ntype is equivalent to ",(0,r.jsx)(n.strong,{children:"float64"})," in golang."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"String"})," - the string can be enclosed in double quotes ",(0,r.jsx)(n.code,{children:'("a string")'})," or\nbackquotes ",(0,r.jsx)(n.code,{children:"(\\`a string\\`)"}),". Both types of strings can contain newline\ncharacters. Strings in double quotes can contain double quotes, newline\ncharacters, and carriage returns escaped with slashes. For example,\n",(0,r.jsx)(n.code,{children:'"This is a \\"first string\\".\\r\\nThis is a second string."'}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Comment"})," - there are two types of comments. Single-line comments use two\nslashes (//). For example, // This is a single-line comment. Multi-line\ncomments use slash and asterisk symbols and can span multiple lines. For\nexample, ",(0,r.jsx)(n.code,{children:"/* This is a multi-line comment */"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Identifier"})," - the names of variables and functions composed of a-z and A-Z\nletters, UTF-8 symbols, numbers and underscores. The name can start with a\nletter, underscore, ",(0,r.jsx)(n.code,{children:"@"})," or ",(0,r.jsx)(n.code,{children:"$"}),". The name starting with ",(0,r.jsx)(n.code,{children:"$"})," is the name of the\nvariable defined in the ",(0,r.jsx)(n.strong,{children:"data section"}),". The name starting with ",(0,r.jsx)(n.code,{children:"$"})," can also\nbe used to define global variables in the scope of ",(0,r.jsx)(n.strong,{children:"conditions"})," and ",(0,r.jsx)(n.strong,{children:"action\nsections"}),". Ecosystem contracts can be called using the ",(0,r.jsx)(n.code,{children:"@"})," symbol. For\nexample: ",(0,r.jsx)(n.code,{children:"@1NewTable(...)"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"types",children:"Types"}),"\n",(0,r.jsx)(n.p,{children:"Corresponding golang types are specified next to theNeedle types."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"bool"})," - bool, ",(0,r.jsx)(n.strong,{children:"false"})," by default;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"bytes"})," - []byte",", an empty byte array by default;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"int"})," - int64, ",(0,r.jsx)(n.strong,{children:"0"})," by default;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"address"})," - uint64, ",(0,r.jsx)(n.strong,{children:"0"})," by default;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"array"})," - []interface",", an empty array by default;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"map"})," - map[string]interface",", an empty object array by default;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"money"})," - decimal. Decimal, ",(0,r.jsx)(n.strong,{children:"0"})," by default;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"float"})," - float64, ",(0,r.jsx)(n.strong,{children:"0"})," by default;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"string"})," - string, an empty string by default;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"file"})," - map[string]interface",", an empty object array by default."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["These types of variables are defined with the ",(0,r.jsx)(n.code,{children:"var"})," keyword. For example,\n",(0,r.jsx)(n.code,{children:"var var1, var2 int"}),". When defined in this way, a variable will be assigned with\na default value by type."]}),"\n",(0,r.jsxs)(n.p,{children:["All variable values are of the interface"," type, and then they are assigned to\nthe required golang types. Therefore, for example, array and map types are\ngolang types []interface"," and map[string]interface",". Both types of arrays can\ncontain elements of any type."]}),"\n",(0,r.jsx)(n.h3,{id:"expressions",children:"Expressions"}),"\n",(0,r.jsx)(n.p,{children:"An expression may include arithmetic operations, logical operations, and\nfunction calls. All expressions are evaluated from left to right by priority of\noperators. If having an equal priority, operators are evaluated from left to\nright."}),"\n",(0,r.jsx)(n.p,{children:"Priority of operations from high to low:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Function call and parentheses"})," - when a function is called, passed\nparameters will be calculated from left to right;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Unary Operation"})," - logical negation ",(0,r.jsx)(n.code,{children:"!"})," and arithmetic sign change ",(0,r.jsx)(n.code,{children:"-"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Multiplication and Division"})," - arithmetic multiplication ",(0,r.jsx)(n.code,{children:"*"})," and division\n",(0,r.jsx)(n.code,{children:"/"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Addition and Subtraction"})," - arithmetic addition ",(0,r.jsx)(n.code,{children:"+"})," and subtraction ",(0,r.jsx)(n.code,{children:"-"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Logical comparison"})," - ",(0,r.jsx)(n.code,{children:">=>> >="}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Logical equality and inequality"})," - ",(0,r.jsx)(n.code,{children:"== !="}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Logical AND"})," - ",(0,r.jsx)(n.code,{children:"&&"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Logical OR"})," - ",(0,r.jsx)(n.code,{children:"||"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"When evaluating logical AND and OR, both sides of the expression are evaluated\nin any case."}),"\n",(0,r.jsxs)(n.p,{children:["Needle has no type checking during compilation. When evaluating operands, an\nattempt is made to convert the type to a more complex type. The type of\ncomplexity order can be as follows: ",(0,r.jsx)(n.code,{children:"string, int, float, money"}),". Only part of\nthe type conversions is implemented. The string type supports addition\noperations, and the result will be string concatenation. For example,\n",(0,r.jsx)(n.code,{children:"string + string = string, money-int = money, int * float = float"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["For functions, type checking is performed on the ",(0,r.jsx)(n.code,{children:"string"})," and ",(0,r.jsx)(n.code,{children:"int"})," types during\nexecution."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"array"})," and ",(0,r.jsx)(n.strong,{children:"map"})," types can be addressed by index. For the ",(0,r.jsx)(n.strong,{children:"array"})," type,\nthe ",(0,r.jsx)(n.strong,{children:"int"})," value must be specified as the index. For the ",(0,r.jsx)(n.strong,{children:"map"})," type, a\nvariable or ",(0,r.jsx)(n.strong,{children:"string"})," value must be specified. If you assign a value to an\n",(0,r.jsx)(n.strong,{children:"array"})," element whose index is greater than the current maximum index, an\nempty element will be added to the array. The initial value of these elements is\n",(0,r.jsx)(n.strong,{children:"nil"}),". For example: .. code:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'var my array\nmy[5] = 0\nvar mymap map\nmymap["index"] = my[3]\n'})}),"\n",(0,r.jsxs)(n.p,{children:["In expressions of conditional logical values (such as ",(0,r.jsx)(n.code,{children:"if, while, &&, ||, !"}),"),\nthe type is automatically converted to a logical value. If the type is not the\ndefault value, it is true."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"var mymap map\nvar val string\nif mymap && val {\n...\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"scope",children:"Scope"}),"\n",(0,r.jsx)(n.p,{children:"Braces specify a block that can contain local scope variables. By default, the\nscope of a variable extends to its own blocks and all nested blocks. In a block,\nyou can define a new variable using the name of an existing variable. However,\nin this case, external variables with the same name become unavailable."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"\nvar a int\na = 3\n{\n   var a int\n   a = 4\n   Println(a) // 4\n}\nPrintln(a) // 3\n"})}),"\n",(0,r.jsx)(n.h3,{id:"contract-execution",children:"Contract execution"}),"\n",(0,r.jsxs)(n.p,{children:["When calling a contract, parameters defined in ",(0,r.jsx)(n.strong,{children:"data"})," must be passed to it.\nBefore executing a contract, the virtual machine receives these parameters and\nassigns them to the corresponding variables ($Param). Then, the predefined\n",(0,r.jsx)(n.strong,{children:"conditions"})," function and ",(0,r.jsx)(n.strong,{children:"action"})," function are called."]}),"\n",(0,r.jsxs)(n.p,{children:["Errors that occur during contract execution can be divided into two types: form\nerrors and environment errors. Form errors are generated using special commands:\n",(0,r.jsx)(n.code,{children:"error, warning, info"})," and when the built-in function returns ",(0,r.jsx)(n.code,{children:"err"})," not equal to\n",(0,r.jsx)(n.em,{children:"nil"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"The Needle language does not handle exceptions. Any error will terminate the\nexecution of contracts. Since a separate stack and structure for saving variable\nvalues are created when a contract is executed, the golang garbage collection\nmechanism will automatically delete these data when a contract is executed."}),"\n",(0,r.jsx)(n.h3,{id:"backus-naur-form-bnf",children:"Backus\u2013Naur Form (BNF)"}),"\n",(0,r.jsx)(n.p,{children:"In computer science, BNF is a notation technique for context-free syntax and is\nusually used to describe the syntax of the language used in computing."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"<decimal digit>"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"<decimal number>"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"<decimal digit> {<decimal digit>}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"<symbol code>"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'''<any symbol>'''\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"<real number>"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"['-'] <decimal number'.'[<decimal number>]\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"<integer number>"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"['-'] <decimal number> | <symbol code>\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"<number>"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'<integer number> | <real number>'\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"<letter>"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'A' |'B' | ... |'Z' |'a' |'b' | ... |'z' | 0x80 | 0x81 | ... | 0xFF\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"<space>"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'0x20'\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"<tabulation>"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'0x09'\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"<newline>"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'0x0D 0x0A'\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"<special symbol>"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'!' |'\"' |'$' |''' |'(' |')' |'\\*' |'+' |',' |'-' |'.' |'/ '|'<' |'=' |'>' |'[' |'\\\\' |']' |'_' |'|' |'}' | '{' | <tabulation> | <space> | <newline>\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"<symbol>"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"<decimal digit> | <letter> | <special symbol>\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"<name>"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"(<letter> |'_') {<letter> |'_' | <decimal digit>}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"<function name>"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"<name>\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"<variable name>"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"<name>\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"<type name>"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"<name>\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"<string symbol>"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"<tabulation> | <space> |'!' |'#' | ... |'[' |']' | ...\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"<string element>"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"{<string symbol> |'\\\"' |'\\n' |'\\r'}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"<string>"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'\"' {<string element>}'\"' |'\\`' {<string element>}'\\`'\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"<assignment operator>"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'='\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"<unary operator>"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'-'\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"<binary operator>"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'==' |'!=' |'>' |'<' |'<=' |'>=' |'&&' |'||' |'\\*' |'/' |'+ '|'-'\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"<operator>"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"<assignment operator> | <unary operator> | <binary operator>\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"<parameters>"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"<expression> {','<expression>}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"<contract call>"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"<contract name>'(' [<parameters>]')'\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"<function call>"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"<contract call> [{'.' <name>'(' [<parameters>]')'}]\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"<block contents>"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"<block command> {<newline><block command>}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"<block>"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'{'<block contents>'}'\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"<block command>"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"(<block> | <expression> | <variables definition> | <if> | <while> | break | continue | return)\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"<if>"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'if <expression><block> [else <block>]'\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"<while>"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'while <expression><block>'\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"<contract>"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'contract <name> '{'[<data section>] {<function>} [<conditions>] [<action>]'}''\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"<data section>"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'data '{' {<data parameter><newline>} '}''\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"<data parameter>"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"<variable name> <type name>'\"'{<tag>}'\"'\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"<tag>"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'optional | image | file | hidden | text | polymap | map | address | signature:<name>'\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"<conditions>"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'conditions <block>'\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"<action>"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'action <block>'\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"<function>"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'func <function name>'('[<variable description>{','<variable description>}]')'[{<tail>}] [<type name>] <block>'\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"<variable description>"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"<variable name> {',' <variable name>} <type name>\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"<tail>"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'.'<function name>'('[<variable description>{','<variable description>}]')'\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"<variables definition>"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'var <variable description>{','<variable description>}'\n"})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>c});var r=t(6540);const s={},i=r.createContext(s);function l(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);