"use strict";(self.webpackChunkmy_ibax=self.webpackChunkmy_ibax||[]).push([[942],{8163:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>x,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var r=s(4848),l=s(8453),t=s(4252);const i={toc_min_heading_level:2,toc_max_heading_level:4},c="Compilateur et Machine Virtuelle {#compiler-and-virtual-machine}",o={id:"topics/vm",title:"Compilateur et Machine Virtuelle",description:"compiler-and-virtual-machine}",source:"@site/i18n/fr/docusaurus-plugin-content-docs/current/topics/vm.md",sourceDirName:"topics",slug:"/topics/vm",permalink:"/docs/fr/topics/vm",draft:!1,unlisted:!1,editUrl:"https://crowdin.com/project/ibax-docs/fr",tags:[],version:"current",frontMatter:{toc_min_heading_level:2,toc_max_heading_level:4},sidebar:"topicsSidebar",previous:{title:"Langage de mod\xe8le",permalink:"/docs/fr/topics/templates2"}},a={},d=[{value:"Stockage et compilation du code source",id:"source-code-storage-and-compilation",level:2},{value:"Structures de machines virtuelles",id:"virtual-machine-structures",level:2},{value:"Structure VM",id:"vm-structure",level:3},{value:"Structure de bloc",id:"block-structure",level:3},{value:"Structure ObjInfo",id:"objinfo-structure",level:3},{value:"Structure ContractInfo",id:"contractinfo-structure",level:4},{value:"Structure FieldInfo",id:"fieldinfo-structure",level:4},{value:"Structure FuncInfo",id:"funcinfo-structure",level:4},{value:"Structure NomFonction",id:"funcname-structure",level:4},{value:"Structure ExtFuncInfo",id:"extfuncinfo-structure",level:4},{value:"Structure VarInfo",id:"varinfo-structure",level:4},{value:"ObjExtend valeur",id:"objextend-value",level:4},{value:"Commandes de machine virtuelle",id:"virtual-machine-commands",level:2},{value:"Structure du ByteCode",id:"bytecode-structure",level:3},{value:"Identifiants de commande",id:"command-identifiers",level:3},{value:"Commandes d&#39;op\xe9rations de pile",id:"stack-operation-commands",level:3},{value:"Structure de Runtime",id:"runtime-structure",level:3},{value:"structure de blockStack",id:"blockstack-structure",level:4},{value:"Fonction RunCode",id:"runcode-function",level:3},{value:"Autres fonctions pour les op\xe9rations avec la VM",id:"other-functions-for-operations-with-vm",level:3},{value:"Compilateur",id:"compiler",level:2},{value:"Analyseur lexical",id:"lexical-analyzer",level:2},{value:"lextable/lextable.go",id:"lextable-lextable-go",level:3},{value:"lex-go",id:"lex-go",level:3},{value:"Langage Needle",id:"needle-language",level:2},{value:"Lexemes",id:"lexemes",level:3},{value:"Types",id:"types",level:3},{value:"Expressions",id:"expressions",level:3},{value:"Port\xe9e",id:"scope",level:3},{value:"Ex\xe9cution de contrat intelligent",id:"contract-execution",level:3},{value:"Forme de Backus-Naur (BNF)",id:"backus-naur-form-bnf",level:3}];function u(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"compiler-and-virtual-machine",children:"Compilateur et Machine Virtuelle"}),"\n",(0,r.jsx)(n.p,{children:"Cette section concerne la compilation du programme et les op\xe9rations du langage\nNeedle dans la machine virtuelle (VM)."}),"\n",(0,r.jsx)(t.A,{toc:d}),"\n",(0,r.jsx)(n.h2,{id:"source-code-storage-and-compilation",children:"Stockage et compilation du code source"}),"\n",(0,r.jsx)(n.p,{children:"Les contrats intelligents et les fonctions sont \xe9crits en Golang et stock\xe9s dans\nles tables de contrat des \xe9cosyst\xe8mes."}),"\n",(0,r.jsx)(n.p,{children:"Lorsqu'un contrat est ex\xe9cut\xe9, son code source est lu depuis la base de donn\xe9es\net compil\xe9 en bytecode."}),"\n",(0,r.jsx)(n.p,{children:"Lorsqu'un contrat est modifi\xe9, son code source est mis \xe0 jour et enregistr\xe9 dans\nla base de donn\xe9es. Ensuite, le code source est compil\xe9, mettant \xe0 jour le\nbytecode dans la machine virtuelle correspondante."}),"\n",(0,r.jsx)(n.p,{children:"Comme les bytecodes ne sont pas physiquement enregistr\xe9s, ils seront compil\xe9s \xe0\nnouveau lorsque le programme sera ex\xe9cut\xe9 \xe0 nouveau."}),"\n",(0,r.jsx)(n.p,{children:"L'ensemble du code source d\xe9crit dans la table de contrat de chaque \xe9cosyst\xe8me\nest compil\xe9 dans une machine virtuelle dans un ordre strict, et l'\xe9tat de la\nmachine virtuelle est le m\xeame sur tous les n\u0153uds."}),"\n",(0,r.jsx)(n.p,{children:"Lorsque le contrat est appel\xe9, la machine virtuelle ne change pas son \xe9tat de\nquelque mani\xe8re que ce soit. L'ex\xe9cution de tout contrat ou l'appel de toute\nfonction se produit sur une pile d'ex\xe9cution distincte cr\xe9\xe9e lors de chaque\nappel externe."}),"\n",(0,r.jsx)(n.p,{children:"Chaque \xe9cosyst\xe8me peut avoir un \xe9cosyst\xe8me virtuel, qui peut \xeatre utilis\xe9 \xe0\nl'int\xe9rieur d'un n\u0153ud en conjonction avec des tables en dehors de la blockchain,\nsans affecter directement la blockchain ou d'autres \xe9cosyst\xe8mes virtuels. Dans\nce cas, le n\u0153ud h\xe9bergeant un tel \xe9cosyst\xe8me virtuel compilera son contrat et\ncr\xe9era sa propre machine virtuelle."}),"\n",(0,r.jsx)(n.h2,{id:"virtual-machine-structures",children:"Structures de machines virtuelles"}),"\n",(0,r.jsx)(n.h3,{id:"vm-structure",children:"Structure VM"}),"\n",(0,r.jsx)(n.p,{children:"Une machine virtuelle est organis\xe9e en m\xe9moire sous la forme d'une structure\ncomme ci-dessous."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"type VM struct {\n   Block\n   ExtCost func(string) int64\n   FuncCallsDB map[string]struct{}\n   Extern bool\n   ShiftContract int64\n   logger *log.Entry\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Une structure de VM comprend les \xe9l\xe9ments suivants :"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Block - contient une ",(0,r.jsx)(n.a,{href:"#block-structure",children:"structure de bloc"}),";"]}),"\n",(0,r.jsx)(n.li,{children:"ExtCost - une fonction qui retourne le co\xfbt d'ex\xe9cution d'une fonction externe\nen Golang;"}),"\n",(0,r.jsx)(n.li,{children:"FuncCallsDB - une collection de noms de fonctions en Golang. Cette fonction\nretourne le co\xfbt d'ex\xe9cution en tant que premier param\xe8tre. Ces fonctions\nutilisent EXPLAIN pour calculer le co\xfbt du traitement de la base de donn\xe9es;"}),"\n",(0,r.jsx)(n.li,{children:"Extern - un indicateur bool\xe9en indiquant si un contrat est un contrat externe.\nIl est d\xe9fini sur true lorsqu'une VM est cr\xe9\xe9e. Les contrats appel\xe9s ne sont\npas affich\xe9s lors de la compilation du code. En d'autres termes, cela permet\nd'appeler le code de contrat d\xe9termin\xe9 ult\xe9rieurement;"}),"\n",(0,r.jsx)(n.li,{children:"ShiftContract - ID du premier contrat dans la VM;"}),"\n",(0,r.jsx)(n.li,{children:"logger - sortie du journal d'erreurs de la VM."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"block-structure",children:"Structure de bloc"}),"\n",(0,r.jsxs)(n.p,{children:["A virtual machine is a tree composed of ",(0,r.jsx)(n.strong,{children:"Block type"})," objects."]}),"\n",(0,r.jsxs)(n.p,{children:["A block is an independent unit that contains some bytecodes. In simple terms,\neverything you put in the braces (",(0,r.jsx)(n.code,{children:"{}"}),") in the language is a block."]}),"\n",(0,r.jsx)(n.p,{children:"For example, the following code would create a block with functions. This block\nalso contains another block with an if statement, which contains a block with a\nwhile statement."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"func my() {\n   if true {\n      while false {\n      ...\n      }\n   }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"The block is organized in the memory as a structure like below."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"type Block struct {\n   Objects map[string]*ObjInfo\n   Type int\n   Owner *OwnerInfo\n   Info interface{}\n   Parent *Block\n   Vars []reflect.Type\n   Code ByteCodes\n   Children Blocks\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Une structure de bloc se compose des \xe9l\xe9ments suivants :"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Objects"})," - une carte d'objets internes de type pointeur\n",(0,r.jsx)(n.a,{href:"#objinfo-structure",children:"ObjInfo"}),". Par exemple, s'il y a une variable dans le\nbloc, vous pouvez obtenir des informations \xe0 son sujet par son nom ;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type"})," - le type du bloc. Pour un bloc de fonction, son type est ",(0,r.jsx)(n.strong,{children:"ObjFunc"}),"\n; pour un bloc de contrat, son type est ",(0,r.jsx)(n.strong,{children:"ObjContract"})," ;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Owner"})," - une structure de type pointeur ",(0,r.jsx)(n.strong,{children:"OwnerInfo"}),". Cette structure\ncontient des informations sur le propri\xe9taire du contrat compil\xe9, qui est\nsp\xe9cifi\xe9 lors de la compilation du contrat ou obtenu \xe0 partir de la table\n",(0,r.jsx)(n.strong,{children:"contracts"})," ;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Info"})," - il contient des informations sur l'objet, qui d\xe9pend du type de\nbloc ;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Parent"})," - un pointeur vers le bloc parent ;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Vars"})," - un tableau contenant les types des variables du bloc actuel ;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Code"})," - le bytecode du bloc lui-m\xeame, qui sera ex\xe9cut\xe9 lorsque les droits\nde contr\xf4le sont transmis au bloc, par exemple, les appels de fonction ou les\ncorps de boucle ;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Children"})," - un tableau contenant des sous-blocs, tels que des fonctions\nimbriqu\xe9es, des boucles, des op\xe9rateurs conditionnels."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"objinfo-structure",children:"Structure ObjInfo"}),"\n",(0,r.jsx)(n.p,{children:"La structure ObjInfo contient des informations sur les objets internes."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"type ObjInfo struct {\n   Type int\n   Value interface{}\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"La structure ObjInfo a les \xe9l\xe9ments suivants:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type"})," est le type d'objet, qui peut avoir l'une des valeurs suivantes :","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ObjContract"})," - ",(0,r.jsx)(n.a,{href:"#contractinfo-structure",children:"contrat"})," ;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ObjFunc"})," - fonction ;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ObjExtFunc"})," - fonction externe golang ;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ObjVar"})," - variable ;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ObjExtend"})," - variable $name."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Value"})," - il contient la structure de chaque type."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"contractinfo-structure",children:"Structure ContractInfo"}),"\n",(0,r.jsxs)(n.p,{children:["Pointant vers le type ",(0,r.jsx)(n.strong,{children:"ObjContract"}),", et le champ ",(0,r.jsx)(n.strong,{children:"Value"})," contient une\nstructure ",(0,r.jsx)(n.strong,{children:"ContractInfo"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"type ContractInfo struct {\n   ID uint32\n   Name string\n   Owner *OwnerInfo\n   Used map[string]bool\n   Tx *[]*FieldInfo\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"La structure ContractInfo comprend les \xe9l\xe9ments suivants :"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ID"})," - ID du contrat, affich\xe9 dans la blockchain lors de l'appel du contrat;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Name"})," - nom du contrat;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Owner"})," - autres informations sur le contrat;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Used"})," - carte des noms de contrats qui ont \xe9t\xe9 appel\xe9s;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Tx"})," - un tableau de donn\xe9es d\xe9crit dans la section\n",(0,r.jsx)(n.a,{href:"/docs/fr/topics/script#data-section",children:"data section"})," du contrat."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"fieldinfo-structure",children:"Structure FieldInfo"}),"\n",(0,r.jsxs)(n.p,{children:["La structure FieldInfo est utilis\xe9e dans la structure ",(0,r.jsx)(n.strong,{children:"ContractInfo"})," et d\xe9crit\nles \xe9l\xe9ments dans ",(0,r.jsx)(n.a,{href:"/docs/fr/topics/script#data-section",children:"data section"})," d'un contrat."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"type FieldInfo struct {\n   Name string\n   Type reflect.Type\n   Original uint32\n   Tags string\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"La structure FieldInfo a les \xe9l\xe9ments suivants :"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Name"})," - nom du champ;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type"})," - type de champ;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Original"})," - champ facultatif;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Tags"})," - \xe9tiquettes suppl\xe9mentaires pour ce champ."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"funcinfo-structure",children:"Structure FuncInfo"}),"\n",(0,r.jsx)(n.p,{children:"Pointant vers le type ObjFunc, et le champ Value contient une structure\nFuncInfo."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"type FuncInfo struct {\n   Params []reflect.Type\n   Results []reflect.Type\n   Names *map[string]FuncName\n   Variadic bool\n   ID uint32\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"La structure FuncInfo comprend les \xe9l\xe9ments suivants :"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Params"})," - un tableau de types de param\xe8tres;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Results"})," - un tableau de types de retour;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Names"})," - une carte de donn\xe9es pour les fonctions de queue, par exemple,\n",(0,r.jsx)(n.code,{children:"DBFind().Columns()"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Variadic"})," - vrai si la fonction peut avoir un nombre variable de\nparam\xe8tres;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ID"})," - ID de la fonction."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"funcname-structure",children:"Structure NomFonction"}),"\n",(0,r.jsx)(n.p,{children:"La structure FuncName est utilis\xe9e pour FuncInfo et d\xe9crit les donn\xe9es d'une\nfonction de queue."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"type FuncName struct {\n   Params []reflect.Type\n   Offset []int\n   Variadic bool\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"La structure FuncName a les \xe9l\xe9ments suivants :"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Params"})," - un tableau de types de param\xe8tres;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Offset"})," - le tableau des d\xe9calages pour ces variables. En fait, les valeurs\nde tous les param\xe8tres dans une fonction peuvent \xeatre initialis\xe9es avec le\npoint .;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Variadic"})," - vrai si la fonction de queue peut avoir un nombre variable de\nparam\xe8tres."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"extfuncinfo-structure",children:"Structure ExtFuncInfo"}),"\n",(0,r.jsx)(n.p,{children:"Pointant vers le type ObjExtFunc, et le champ Value contient une structure\nExtFuncInfo. Il est utilis\xe9 pour d\xe9crire les fonctions golang."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"type ExtFuncInfo struct {\n   Name string\n   Params []reflect.Type\n   Results []reflect.Type\n   Auto []string\n   Variadic bool\n   Func interface{}\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"La structure ExtFuncInfo comprend les \xe9l\xe9ments suivants :"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Name"}),", ",(0,r.jsx)(n.strong,{children:"Params"}),", ",(0,r.jsx)(n.strong,{children:"Results"})," les param\xe8tres ont la m\xeame structure que\n",(0,r.jsx)(n.a,{href:"#funcinfo-structure",children:"FuncInfo"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Auto"})," - un tableau de variables. Si pr\xe9sent, il est transmis \xe0 la fonction\nen tant que param\xe8tre suppl\xe9mentaire. Par exemple, une variable de type\nSmartContract sc;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Func"})," - fonctions golang."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"varinfo-structure",children:"Structure VarInfo"}),"\n",(0,r.jsxs)(n.p,{children:["En pointant vers le type ",(0,r.jsx)(n.strong,{children:"ObjVar"}),", et le champ ",(0,r.jsx)(n.strong,{children:"Value"})," contient une\nstructure ",(0,r.jsx)(n.strong,{children:"VarInfo"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"type VarInfo struct {\n   Obj *ObjInfo\n   Owner *Block\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"La structure VarInfo a les \xe9l\xe9ments suivants :"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Obj"})," - informations sur le type et la valeur de la variable;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Owner"})," - Pointeur vers le bloc propri\xe9taire."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"objextend-value",children:"ObjExtend valeur"}),"\n",(0,r.jsxs)(n.p,{children:["En pointant vers le type ",(0,r.jsx)(n.strong,{children:"ObjExtend"}),", et le champ ",(0,r.jsx)(n.strong,{children:"Value"})," contient une\ncha\xeene de caract\xe8res contenant le nom de la variable ou de la fonction."]}),"\n",(0,r.jsx)(n.h2,{id:"virtual-machine-commands",children:"Commandes de machine virtuelle"}),"\n",(0,r.jsx)(n.h3,{id:"bytecode-structure",children:"Structure du ByteCode"}),"\n",(0,r.jsxs)(n.p,{children:["Un bytecode est une s\xe9quence de structures de type ",(0,r.jsx)(n.strong,{children:"ByteCode"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"type ByteCode struct {\n   Cmd uint16\n   Value interface{}\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Cette structure a les champs suivants:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cmd"})," - l'identifiant des commandes de stockage;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Value"})," - contient l'op\xe9rande (valeur)."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"En g\xe9n\xe9ral, les commandes effectuent une op\xe9ration sur l'\xe9l\xe9ment sup\xe9rieur de la\npile et \xe9crivent la valeur r\xe9sultante si n\xe9cessaire."}),"\n",(0,r.jsx)(n.h3,{id:"command-identifiers",children:"Identifiants de commande"}),"\n",(0,r.jsx)(n.p,{children:"Les identifiants des commandes de la machine virtuelle sont d\xe9crits dans le\nfichier vm/cmds_list.go."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdPush"})," - mettre une valeur du champ ",(0,r.jsx)(n.code,{children:"Value"})," dans la pile. Par exemple,\nmettre des nombres et des lignes dans la pile;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdVar"})," - mettre la valeur d'une variable dans la pile. ",(0,r.jsx)(n.code,{children:"Value"})," contient un\npointeur vers la structure ",(0,r.jsx)(n.code,{children:"VarInfo"})," et des informations sur la variable;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdExtend"})," - mettre la valeur d'une variable externe dans la pile. ",(0,r.jsx)(n.code,{children:"Value"}),"\ncontient une cha\xeene de caract\xe8res avec le nom de la variable (commen\xe7ant par\n",(0,r.jsx)(n.code,{children:"$"}),");"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdCallExtend"})," - appeler une fonction externe (commen\xe7ant par ",(0,r.jsx)(n.code,{children:"$"}),"). Les\nparam\xe8tres de la fonction sont obtenus \xe0 partir de la pile et les r\xe9sultats\nsont plac\xe9s dans la pile. ",(0,r.jsx)(n.code,{children:"Value"})," contient le nom de la fonction (commen\xe7ant\npar ",(0,r.jsx)(n.code,{children:"$"}),");"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdPushStr"})," - mettre la cha\xeene de caract\xe8res contenue dans ",(0,r.jsx)(n.code,{children:"Value"})," dans la\npile;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdCall"})," - appelle la fonction de la machine virtuelle. ",(0,r.jsx)(n.code,{children:"Value"})," contient\nune structure ",(0,r.jsx)(n.code,{children:"ObjInfo"}),". Cette commande s'applique \xe0 la fonction golang\n",(0,r.jsx)(n.code,{children:"ObjExtFunc"})," et \xe0 la fonction Needle ",(0,r.jsx)(n.code,{children:"ObjFunc"}),". Si une fonction est appel\xe9e,\nses param\xe8tres sont obtenus \xe0 partir de la pile et les valeurs de r\xe9sultat\nsont plac\xe9es dans la pile;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdCallVari"})," - similaire \xe0 la commande ",(0,r.jsx)(n.strong,{children:"cmdCall"}),", elle appelle la\nfonction de la machine virtuelle. Cette commande est utilis\xe9e pour appeler une\nfonction avec un nombre variable de param\xe8tres;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdReturn"})," - utilis\xe9e pour sortir de la fonction. Les valeurs de retour\nseront plac\xe9es dans la pile et le champ ",(0,r.jsx)(n.code,{children:"Value"})," n'est pas utilis\xe9;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdIf"})," - transf\xe8re le contr\xf4le vers le bytecode dans la structure ",(0,r.jsx)(n.code,{children:"block"}),",\nqui est transmis dans le champ ",(0,r.jsx)(n.code,{children:"Value"}),". Le contr\xf4le sera transf\xe9r\xe9 dans la\npile uniquement lorsque l'\xe9l\xe9ment sup\xe9rieur de la pile est appel\xe9 par la\nfonction ",(0,r.jsx)(n.code,{children:"valueToBool"})," et retourne ",(0,r.jsx)(n.code,{children:"true"}),". Sinon, le contr\xf4le sera transf\xe9r\xe9 \xe0\nla commande suivante;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdElse"})," - cette commande fonctionne de la m\xeame mani\xe8re que ",(0,r.jsx)(n.strong,{children:"cmdIf"}),", mais\nseulement lorsque l'\xe9l\xe9ment sup\xe9rieur de la pile est appel\xe9 par la fonction\n",(0,r.jsx)(n.code,{children:"valueToBool"})," et retourne ",(0,r.jsx)(n.code,{children:"false"}),", le contr\xf4le sera transf\xe9r\xe9 au bloc\nsp\xe9cifi\xe9;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdAssignVar"})," - obtenir une liste de variables de type ",(0,r.jsx)(n.code,{children:"VarInfo"})," \xe0 partir\nde ",(0,r.jsx)(n.code,{children:"Value"}),". Ces variables utilisent la commande ",(0,r.jsx)(n.strong,{children:"cmdAssign"})," pour obtenir la\nvaleur;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdAssign"})," - assigner la valeur de la pile \xe0 la variable obtenue par la\ncommande ",(0,r.jsx)(n.strong,{children:"cmdAssignVar"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdLabel"})," - d\xe9finit une \xe9tiquette lorsque le contr\xf4le est renvoy\xe9 pendant\nla boucle while;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdContinue"})," - cette commande transf\xe8re le contr\xf4le vers l'\xe9tiquette\n",(0,r.jsx)(n.strong,{children:"cmdLabel"}),". Lors de l'ex\xe9cution d'une nouvelle it\xe9ration de la boucle,\n",(0,r.jsx)(n.code,{children:"Value"})," n'est pas utilis\xe9;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdWhile"})," - utilise ",(0,r.jsx)(n.code,{children:"valueToBool"})," pour v\xe9rifier l'\xe9l\xe9ment sup\xe9rieur de la\npile. Si cette valeur est ",(0,r.jsx)(n.code,{children:"true"}),", la structure ",(0,r.jsx)(n.code,{children:"block"})," sera appel\xe9e depuis le\nchamp ",(0,r.jsx)(n.code,{children:"Value"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdBreak"})," - quitte la boucle;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdIndex"})," - mettre la valeur de la map ou du tableau dans la pile par\nindex, sans utiliser ",(0,r.jsx)(n.code,{children:"Value"}),". Par exemple,\n",(0,r.jsx)(n.code,{children:"(map | tableau) (index valeur) => (map | tableau [index valeur])"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdSetIndex"})," - assigne la valeur de l'\xe9l\xe9ment sup\xe9rieur de la pile aux\n\xe9l\xe9ments de la map ou du tableau, sans utiliser ",(0,r.jsx)(n.code,{children:"Value"}),". Par exemple,\n",(0,r.jsx)(n.code,{children:"(map | tableau) (index valeur) (valeur) => (map | tableau)"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdFuncName"})," - ajoute les param\xe8tres qui sont pass\xe9s en utilisant des\ndescriptions s\xe9quentielles divis\xe9es par un point ",(0,r.jsx)(n.code,{children:". Par exemple, "}),"func name =>\nFunc (...) .Name (...)`;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdUnwrapArr"})," - d\xe9finit un indicateur bool\xe9en si l'\xe9l\xe9ment sup\xe9rieur de la\npile est un tableau;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdMapInit"})," - initialise la valeur de la map;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdArrayInit"})," - initialise la valeur du tableau;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdError"})," - cette commande est cr\xe9\xe9e lorsque qu'un contrat ou une fonction\nse termine avec une erreur, un avertissement ou une information sp\xe9cifi\xe9e."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"stack-operation-commands",children:"Commandes d'op\xe9rations de pile"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Remarque"}),"\n"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Dans la version actuelle, la conversion automatique de type n'est pas\nenti\xe8rement applicable pour ces commandes. Par exemple,"}),"\n"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"string + float | int | decimal => float | int | decimal, float + int | str => float, mais int + string => erreur d'ex\xe9cution"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Les commandes suivantes sont destin\xe9es au traitement direct de la pile. Le champ\nValeur n'est pas utilis\xe9 dans ces commandes."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdNot"})," - logical negation. ",(0,r.jsx)(n.code,{children:"(val) => (!ValueToBool(val))"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdSign"})," - change of sign. ",(0,r.jsx)(n.code,{children:"(val) => (-val)"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdAdd"})," - addition. ",(0,r.jsx)(n.code,{children:"(val1)(val2) => (val1 + val2)"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdSub"})," - subtraction. ",(0,r.jsx)(n.code,{children:"(val1)(val2) => (val1 - val2)"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdMul"})," - multiplication. ",(0,r.jsx)(n.code,{children:"(val1)(val2) => (val1 * val2)"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdDiv"})," - division. ",(0,r.jsx)(n.code,{children:"(val1)(val2) => (val1 / val2)"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdAnd"})," - logical AND.\n",(0,r.jsx)(n.code,{children:"(val1)(val2) => (valueToBool(val1) && valueToBool(val2))"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdOr"})," - logical OR.\n",(0,r.jsx)(n.code,{children:"(val1)(val2) => (valueToBool(val1) || valueToBool(val2))"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdEqual"})," - equality comparison, bool is returned.\n",(0,r.jsx)(n.code,{children:"(val1)(val2) => (val1 == val2)"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdNotEq"})," - inequality comparison, bool is returned.\n",(0,r.jsx)(n.code,{children:"(val1)(val2) => (val1 != val2)"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdLess"})," - less-than comparison, bool is returned.\n",(0,r.jsx)(n.code,{children:"(val1)(val2) => (val1 < val2)"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdNotLess"})," - greater-than-or-equal comparison, bool is returned.\n",(0,r.jsx)(n.code,{children:"(val1)(val2) => (val1 >= val2)"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdGreat"})," - greater-than comparison, bool is returned.\n",(0,r.jsx)(n.code,{children:"(val1)(val2) => (val1 > val2)"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cmdNotGreat"})," - less-than-or-equal comparison, bool is returned.\n",(0,r.jsx)(n.code,{children:"(val1)(val2) => (val1 <= val2)"}),";"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"runtime-structure",children:"Structure de Runtime"}),"\n",(0,r.jsx)(n.p,{children:"L'ex\xe9cution des octets de code n'affectera pas la machine virtuelle. Par\nexemple, cela permet \xe0 diff\xe9rentes fonctions et contrats de s'ex\xe9cuter\nsimultan\xe9ment dans une seule machine virtuelle. La structure Runtime est\nutilis\xe9e pour ex\xe9cuter des fonctions et des contrats, ainsi que des expressions\net des octets de code."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"type RunTime struct {\n   stack []interface{}\n   blocks []*blockStack\n   vars []interface{}\n   extend *map[string]interface{}\n   vm *VM\n   cost int64\n   err error\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"stack"})," - la pile d'ex\xe9cution du bytecode;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"blocks"})," - la pile des appels de blocs;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"vars"})," - la pile des variables. Ses variables seront ajout\xe9es \xe0 la pile des\nvariables lors de l'appel du bytecode dans le bloc. Apr\xe8s la sortie du bloc,\nla taille de la pile des variables reviendra \xe0 sa valeur pr\xe9c\xe9dente;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"extend"})," - un pointeur vers une carte avec les valeurs des variables\nexternes (",(0,r.jsx)(n.code,{children:"$name"}),");"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"vm"})," - un pointeur vers la machine virtuelle;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"cost"})," - l'unit\xe9 de carburant du co\xfbt d'ex\xe9cution r\xe9sultant;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"err"})," - une erreur s'est produite lors de l'ex\xe9cution."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"blockstack-structure",children:"structure de blockStack"}),"\n",(0,r.jsx)(n.p,{children:"La structure blockStack est utilis\xe9e dans la structure Runtime."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"type blockStack struct {\n   Block *Block\n   Offset int\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Block"})," - un pointeur vers le bloc en cours d'ex\xe9cution;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Offset"})," - le d\xe9calage de la derni\xe8re commande ex\xe9cut\xe9e dans le bytecode du\nbloc sp\xe9cifi\xe9."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"runcode-function",children:"Fonction RunCode"}),"\n",(0,r.jsxs)(n.p,{children:["Les octets de code sont ex\xe9cut\xe9s dans la fonction ",(0,r.jsx)(n.strong,{children:"RunCode"}),". Elle contient une\nboucle qui effectue l'op\xe9ration correspondante pour chaque commande d'octet de\ncode. Avant de traiter un octet de code, les donn\xe9es requises doivent \xeatre\ninitialis\xe9es."]}),"\n",(0,r.jsx)(n.p,{children:"De nouveaux blocs sont ajout\xe9s \xe0 d'autres blocs."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"rt.blocks = append(rt.blocks, &blockStack{block, len(rt.vars)})\n"})}),"\n",(0,r.jsx)(n.p,{children:'Ensuite, obtenez les informations des param\xe8tres pertinents de la fonction\n"tail". Ces param\xe8tres sont contenus dans le dernier \xe9l\xe9ment de la pile.'}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"var namemap map[string][]interface{}\nif block.Type == ObjFunc && block.Info.(*FuncInfo).Names != nil {\n   if rt.stack[len(rt.stack)-1] != nil {\n      namemap = rt.stack[len(rt.stack)-1].(map[string][]interface{})\n   }\n   rt.stack = rt.stack[:len(rt.stack)-1]\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Ensuite, toutes les variables d\xe9finies dans le bloc actuel doivent \xeatre\ninitialis\xe9es avec leurs valeurs initiales."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"start := len(rt.stack)\nvaroff := len(rt.vars)\nfor vkey, vpar := range block.Vars {\n   rt.cost--\n   var value interface{}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Puisque les variables dans la fonction sont \xe9galement des variables, nous devons\nles r\xe9cup\xe9rer \xe0 partir du dernier \xe9l\xe9ment de la pile dans l'ordre d\xe9crit par la\nfonction elle-m\xeame."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"   if block.Type == ObjFunc && vkey <len(block.Info.(*FuncInfo).Params) {\n      value = rt.stack[start-len(block.Info.(*FuncInfo).Params)+vkey]\n   } else {\n"})}),"\n",(0,r.jsx)(n.p,{children:"Initialisez les variables locales avec leurs valeurs initiales."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"      value = reflect.New(vpar).Elem().Interface()\n\n      if vpar == reflect.TypeOf(map[string]interface{}{}) {\n\n         value = make(map[string]interface{})\n      } else if vpar == reflect.TypeOf([]interface{}{}) {\n         value = make([]interface{}, 0, len(rt.vars)+1)\n      }\n   }\n   rt.vars = append(rt.vars, value)\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Ensuite, mettez \xe0 jour les valeurs des param\xe8tres variables pass\xe9s dans la\nfonction tail."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"if namemap != nil {\n   for key, item := range namemap {\n      params := (*block.Info.(*FuncInfo).Names)[key]\n      for i, value := range item {\n         if params.Variadic && i >= len(params.Params)-1 {\n"})}),"\n",(0,r.jsx)(n.p,{children:"Si les param\xe8tres de variable pass\xe9s appartiennent \xe0 un nombre variable de\nparam\xe8tres, alors ces param\xe8tres seront combin\xe9s dans un tableau de variables."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"            off := varoff + params.Offset[len(params.Params)-1]\n            rt.vars[off] = append(rt.vars[off].([]interface{}), value)\n         } else {\n            rt.vars[varoff+params.Offset[i]] = value\n         }\n      }\n   }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Apr\xe8s cela, tout ce que nous avons \xe0 faire est de supprimer les valeurs pass\xe9es\ndepuis le sommet de la pile en tant que param\xe8tres de fonction, d\xe9pla\xe7ant ainsi\nla pile. Nous avons copi\xe9 leurs valeurs dans un tableau de variables."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"if block.Type == ObjFunc {\n   start -= len(block.Info.(*FuncInfo).Params)\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Lorsqu'une boucle de commande bytecode est termin\xe9e, nous devons vider\ncorrectement la pile."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"last := rt.blocks[len(rt.blocks)-1]\n"})}),"\n",(0,r.jsx)(n.p,{children:"Supprimer le bloc actuel de la pile de blocs."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"rt.blocks = rt.blocks[:len(rt.blocks)-1]\nif status == statusReturn {\n"})}),"\n",(0,r.jsx)(n.p,{children:"Si la sortie de la fonction s'est effectu\xe9e avec succ\xe8s, nous ajouterons la\nvaleur de retour \xe0 la fin de la pile pr\xe9c\xe9dente."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"   if last.Block.Type == ObjFunc {\n      for count := len(last.Block.Info.(*FuncInfo).Results); count > 0; count-- {\n         rt.stack[start] = rt.stack[len(rt.stack)-count]\n         start++\n      }\n      status = statusNormal\n   } else {\n"})}),"\n",(0,r.jsx)(n.p,{children:"Comme vous pouvez le voir, si nous n'ex\xe9cutons pas la fonction, alors nous ne\nrestaurerons pas l'\xe9tat de la pile et sortirons de la fonction telle quelle. La\nraison en est que les boucles et les structures conditionnelles qui ont \xe9t\xe9\nex\xe9cut\xe9es dans la fonction sont \xe9galement des blocs de code bytecode."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"   return\n\n   }\n}\n\nrt.stack = rt.stack[:start]\n"})}),"\n",(0,r.jsx)(n.h3,{id:"other-functions-for-operations-with-vm",children:"Autres fonctions pour les op\xe9rations avec la VM"}),"\n",(0,r.jsxs)(n.p,{children:["Vous pouvez cr\xe9er une machine virtuelle avec la fonction ",(0,r.jsx)(n.strong,{children:"NewVM"}),". Chaque\nmachine virtuelle sera ajout\xe9e avec quatre fonctions, telles que\n",(0,r.jsx)(n.strong,{children:"ExecContract"}),", ",(0,r.jsx)(n.strong,{children:"MemoryUsage"}),", ",(0,r.jsx)(n.strong,{children:"CallContract"})," et ",(0,r.jsx)(n.strong,{children:"Settings"}),", gr\xe2ce \xe0 la\nfonction ",(0,r.jsx)(n.strong,{children:"Extend"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"for key, item := range ext.Objects {\n   fobj := reflect.ValueOf(item).Type()\n"})}),"\n",(0,r.jsx)(n.p,{children:"Nous parcourons tous les objets pass\xe9s et ne regardons que les fonctions."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"   switch fobj.Kind() {\n   case reflect.Func:\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Nous remplissons la structure ",(0,r.jsx)(n.strong,{children:"ExtFuncInfo"})," en fonction des informations\nre\xe7ues sur la fonction, et ajoutons sa structure \xe0 la carte de niveau sup\xe9rieur\n",(0,r.jsx)(n.strong,{children:"Objects"})," par nom."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"   data := ExtFuncInfo{key, make([]reflect.Type, fobj.NumIn()), make([]reflect.Type, fobj.NumOut()),\n   make([]string, fobj.NumIn()), fobj.IsVariadic(), item}\n   for i := 0; i <fobj.NumIn(); i++ {\n"})}),"\n",(0,r.jsxs)(n.p,{children:["La structure ",(0,r.jsx)(n.strong,{children:"ExtFuncInfo"})," a un tableau de param\xe8tres ",(0,r.jsx)(n.strong,{children:"Auto"}),".\nHabituellement, le premier param\xe8tre est ",(0,r.jsx)(n.code,{children:"sc *SmartContract"})," ou ",(0,r.jsx)(n.code,{children:"rt *Runtime"}),",\nnous ne pouvons pas les passer depuis le langage Needle, car ils sont\nn\xe9cessaires pour ex\xe9cuter certaines fonctions golang. Par cons\xe9quent, nous\nsp\xe9cifions que ces variables seront utilis\xe9es automatiquement lorsque ces\nfonctions sont appel\xe9es. Dans ce cas, le premier param\xe8tre des quatre fonctions\nci-dessus est ",(0,r.jsx)(n.code,{children:"rt *Runtime"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"   if isauto, ok := ext.AutoPars[fobj.In(i).String()]; ok {\n      data.Auto[i] = isauto\n   }\n"})}),"\n",(0,r.jsx)(n.p,{children:"Informations sur l'attribution des param\xe8tres."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"      data.Params[i] = fobj.In(i)\n   }\n"})}),"\n",(0,r.jsx)(n.p,{children:"Et les types de valeurs de retour."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"for i := 0; i <fobj.NumOut(); i++ {\n   data.Results[i] = fobj.Out(i)\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Ajoute une fonction \xe0 la racine ",(0,r.jsx)(n.strong,{children:"Objects"})," afin que le compilateur puisse les\ntrouver ult\xe9rieurement lors de l'utilisation du contrat."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"      vm.Objects[key] = &ObjInfo{ObjExtFunc, data}\n   }\n\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"compiler",children:"Compilateur"}),"\n",(0,r.jsx)(n.p,{children:"Les fonctions dans le fichier compile.go sont responsables de la compilation du\ntableau de jetons obtenus \xe0 partir de l'analyse lexicale. La compilation peut\n\xeatre divis\xe9e en deux niveaux de mani\xe8re conditionnelle. Au niveau sup\xe9rieur,\nnous traitons des fonctions, des contrats, des blocs de code, des d\xe9clarations\nconditionnelles et de boucle, des d\xe9finitions de variables, etc. Au niveau\ninf\xe9rieur, nous compilons les expressions dans les blocs de code ou les\nconditions dans les boucles et les d\xe9clarations conditionnelles."}),"\n",(0,r.jsxs)(n.p,{children:["Tout d'abord, nous commencerons par le niveau inf\xe9rieur simple. Dans la fonction\n",(0,r.jsx)(n.strong,{children:"compileEval"}),", les expressions peuvent \xeatre converties en bytecode. \xc9tant\ndonn\xe9 que nous utilisons une machine virtuelle avec une pile, il est n\xe9cessaire\nde convertir les expressions d'enregistrement infixes ordinaires en notation\npostfixe ou en notation polonaise inverse. Par exemple, nous convertissons ",(0,r.jsx)(n.code,{children:"1+2"}),"\nen ",(0,r.jsx)(n.code,{children:"12+"})," et pla\xe7ons ",(0,r.jsx)(n.code,{children:"1"})," et ",(0,r.jsx)(n.code,{children:"2"})," dans la pile. Ensuite, nous appliquons\nl'op\xe9ration d'addition aux deux derniers \xe9l\xe9ments de la pile et \xe9crivons le\nr\xe9sultat dans la pile. Vous pouvez trouver cet algorithme de\n",(0,r.jsx)(n.a,{href:"https://master.virmandy.net/perevod-iz-infiksnoy-notatsii-v-postfiksnuyu-obratnaya-polskaya-zapis/",children:"conversion"}),"\nsur Internet."]}),"\n",(0,r.jsxs)(n.p,{children:["La variable globale ",(0,r.jsx)(n.code,{children:"opers = map [uint32] operPrior"})," contient la priorit\xe9 des\nop\xe9rations n\xe9cessaires pour la conversion en notation polonaise inverse."]}),"\n",(0,r.jsxs)(n.p,{children:["Les variables suivantes sont d\xe9finies au d\xe9but de la fonction ",(0,r.jsx)(n.strong,{children:"compileEval"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"buffer"})," - tampon temporaire pour les commandes de bytecode ;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"bytecode"})," - tampon final des commandes de bytecode ;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"parcount"})," - tampon temporaire utilis\xe9 pour calculer les param\xe8tres lors de\nl'appel d'une fonction ;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"setIndex"})," - les variables dans le processus de travail seront d\xe9finies sur\ntrue lorsque nous attribuons des \xe9l\xe9ments de carte ou de tableau. Par exemple,\n",(0,r.jsx)(n.code,{children:'a["my"] = 10'}),". Dans ce cas, nous devons utiliser la commande ",(0,r.jsx)(n.strong,{children:"cmdSetIndex"}),"\nsp\xe9cifi\xe9e."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Nous obtenons un jeton dans une boucle et le traitons en cons\xe9quence. Par\nexemple, l'appariement des expressions s'arr\xeatera si des parenth\xe8ses sont\ntrouv\xe9es. Lors du d\xe9placement de la cha\xeene, nous v\xe9rifions si l'instruction\npr\xe9c\xe9dente est une op\xe9ration et si elle se trouve entre parenth\xe8ses, sinon elle\nsortira de l'expression analys\xe9e."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"case isRCurly, isLCurly:\n   i--\n   if prevLex == isComma || prevLex == lexOper {\n      return errEndExp\n   }\n   break main\ncase lexNewLine:\n   if i > 0 && ((*lexems)[i-1].Type == isComma || (*lexems)[i-1].Type == lexOper) {\n      continue main\n   }\n   for k := len(buffer) - 1; k >= 0; k-- {\n   if buffer[k].Cmd == cmdSys {\n      continue main\n   }\n}\nbreak main\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"En g\xe9n\xe9ral, l'algorithme lui-m\xeame correspond \xe0 un algorithme de conversion en\nnotation polonaise inverse. Avec la prise en compte de l'appel des contrats,\nfonctions et index n\xe9cessaires, ainsi que d'autres \xe9l\xe9ments non rencontr\xe9s lors\nde l'analyse syntaxique et des options pour l'analyse des jetons de type\nlexIdent, alors les variables, fonctions ou contrats avec ce nom seront\nv\xe9rifi\xe9s. Si rien n'est trouv\xe9 et que ce n'est pas un appel de fonction ou de\ncontrat, alors une erreur sera indiqu\xe9e."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"objInfo, tobj := vm.findObj(lexem.Value.(string), block)\nif objInfo == nil && (!vm.Extern || i> *ind || i >= len(*lexems)-2 || (*lexems)[i+1].Type != isLPar) {\n   return fmt.Errorf(`unknown identifier %s`, lexem.Value.(string))\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Nous pourrions rencontrer une telle situation, et l'appel de contrat sera d\xe9crit\nult\xe9rieurement. Dans cet exemple, si aucune fonction ou variable avec le m\xeame\nnom n'est trouv\xe9e, alors nous pensons qu'il est n\xe9cessaire d'appeler un contrat.\nDans ce langage compil\xe9, il n'y a pas de diff\xe9rence entre les contrats et les\nappels de fonction. Mais nous devons appeler le contrat \xe0 travers la fonction\n",(0,r.jsx)(n.strong,{children:"ExecContract"})," utilis\xe9e dans le bytecode."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"if objInfo.Type == ObjContract {\n   if objInfo.Value != nil {\n      objContract = objInfo.Value.(*Block)\n   }\n   objInfo, tobj = vm.findObj(`ExecContract`, block)\n   isContract = true\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Nous enregistrons le nombre de variables jusqu'\xe0 pr\xe9sent dans ",(0,r.jsx)(n.code,{children:"count"}),", qui sera\n\xe9galement \xe9crit dans la pile avec le nombre de param\xe8tres de la fonction. \xc0\nchaque d\xe9tection ult\xe9rieure de param\xe8tres, nous devons simplement augmenter ce\nnombre d'une unit\xe9 sur le dernier \xe9l\xe9ment de la pile."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"count := 0\nif (*lexems)[i+2].Type != isRPar {\n   count++\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:['Nous avons une liste appel\xe9e "Used" de param\xe8tres pour les contrats, puis nous\ndevons marquer le cas o\xf9 le contrat est appel\xe9. Si le contrat est appel\xe9 sans\nparam\xe8tres, nous devons ajouter deux param\xe8tres vides pour appeler\n',(0,r.jsx)(n.strong,{children:"ExecContract"})," et obtenir au moins deux param\xe8tres."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'if isContract {\n   name := StateName((*block)[0].Info.(uint32), lexem.Value.(string))\n   for j := len(*block) - 1; j >= 0; j-- {\n   topblock := (*block)[j]\n      if topblock.Type == ObjContract {\n         if topblock.Info.(*ContractInfo).Used == nil {\n            topblock.Info.(*ContractInfo).Used = make(map[string]bool)\n         }\n         topblock.Info.(*ContractInfo).Used[name] = true\n      }\n   }\n   bytecode = append(bytecode, &ByteCode{cmdPush, name})\n   if count == 0 {\n      count = 2\n      bytecode = append(bytecode, &ByteCode{cmdPush, ""})\n      bytecode = append(bytecode, &ByteCode{cmdPush, ""})\n   }\n   count++\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Si nous voyons qu'il y a une parenth\xe8se carr\xe9e \xe0 c\xf4t\xe9, alors nous ajoutons la\ncommande ",(0,r.jsx)(n.strong,{children:"cmdIndex"})," pour obtenir la valeur par l'index."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"if (*lexems)[i+1].Type == isLBrack {\n   if objInfo == nil || objInfo.Type != ObjVar {\n      return fmt.Errorf(`unknown variable %s`, lexem.Value.(string))\n   }\n   buffer = append(buffer, &ByteCode{cmdIndex, 0})\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["La fonction ",(0,r.jsx)(n.strong,{children:"CompileBlock"})," peut g\xe9n\xe9rer des arbres d'objets et des octets de\ncode ind\xe9pendants de l'expression. Le processus de compilation est bas\xe9 sur une\nmachine \xe0 \xe9tats finis, tout comme un analyseur lexical, mais avec les\ndiff\xe9rences suivantes. Premi\xe8rement, nous n'utilisons pas de symboles mais des\njetons ; deuxi\xe8mement, nous d\xe9crirons imm\xe9diatement les variables ",(0,r.jsx)(n.em,{children:"states"})," dans\ntous les \xe9tats et transitions. Il repr\xe9sente un tableau d'objets index\xe9s par\ntype de jeton. Chaque jeton a une structure de ",(0,r.jsx)(n.em,{children:"compileState"}),", et un nouvel \xe9tat\nest sp\xe9cifi\xe9 dans ",(0,r.jsx)(n.em,{children:"NewState"}),". Si la structure que nous avons r\xe9solue est claire,\nnous pouvons sp\xe9cifier la fonction du gestionnaire dans le champ ",(0,r.jsx)(n.em,{children:"Func"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"Prenons l'\xe9tat principal comme exemple."}),"\n",(0,r.jsxs)(n.p,{children:["Si nous rencontrons un saut de ligne ou un commentaire, nous resterons dans le\nm\xeame \xe9tat. Si nous rencontrons le mot-cl\xe9 ",(0,r.jsx)(n.strong,{children:"contract"}),", alors nous changeons\nl'\xe9tat en ",(0,r.jsx)(n.em,{children:"stateContract"})," et commen\xe7ons \xe0 analyser la structure. Si nous\nrencontrons le mot-cl\xe9 ",(0,r.jsx)(n.strong,{children:"func"}),", alors nous changeons l'\xe9tat en ",(0,r.jsx)(n.em,{children:"stateFunc"}),". Si\nd'autres jetons sont re\xe7us, la fonction g\xe9n\xe9rant une erreur sera appel\xe9e."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"{// stateRoot\n   lexNewLine: {stateRoot, 0},\n   lexKeyword | (keyContract << 8): {stateContract | statePush, 0},\n   lexKeyword | (keyFunc << 8): {stateFunc | statePush, 0},\n   lexComment: {stateRoot, 0},\n   0: {errUnknownCmd, cfError},\n},\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Supposons que nous rencontrions le mot-cl\xe9 ",(0,r.jsx)(n.strong,{children:"func"})," et que nous ayons chang\xe9\nl'\xe9tat en ",(0,r.jsx)(n.em,{children:"stateFunc"}),". \xc9tant donn\xe9 que le nom de la fonction doit suivre le\nmot-cl\xe9 ",(0,r.jsx)(n.strong,{children:"func"}),", nous conserverons le m\xeame \xe9tat lors du changement du nom de la\nfonction. Pour tous les autres jetons, nous g\xe9n\xe9rerons des erreurs\ncorrespondantes. Si nous obtenons le nom de la fonction dans l'identificateur du\njeton, alors nous passons \xe0 l'\xe9tat ",(0,r.jsx)(n.em,{children:"stateFParams"}),", o\xf9 nous pouvons obtenir les\nparam\xe8tres de la fonction."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"{// stateFunc\n   lexNewLine: {stateFunc, 0},\n   lexIdent: {stateFParams, cfNameBlock},\n   0: {errMustName, cfError},\n},\n"})}),"\n",(0,r.jsxs)(n.p,{children:["En m\xeame temps que les op\xe9rations ci-dessus, nous appellerons la fonction\n",(0,r.jsx)(n.strong,{children:"fNameBlock"}),". Il convient de noter que la structure Block est cr\xe9\xe9e avec la\nmarque statePush, o\xf9 nous l'obtenons \xe0 partir du tampon et la remplissons avec\nles donn\xe9es dont nous avons besoin. La fonction ",(0,r.jsx)(n.strong,{children:"fNameBlock"})," convient aux\ncontrats et aux fonctions (y compris celles qui sont imbriqu\xe9es). Elle remplit\nle champ ",(0,r.jsx)(n.em,{children:"Info"})," avec la structure correspondante et s'\xe9crit elle-m\xeame dans les\n",(0,r.jsx)(n.em,{children:"Objets"})," du bloc parent. De cette mani\xe8re, nous pouvons appeler la fonction ou\nle contrat avec le nom sp\xe9cifi\xe9. De m\xeame, nous cr\xe9ons des fonctions\ncorrespondantes pour tous les \xe9tats et variables. Ces fonctions sont\ng\xe9n\xe9ralement tr\xe8s petites et effectuent certaines t\xe2ches lors de la construction\nde l'arbre de la machine virtuelle."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"func fNameBlock(buf *[]*Block, state int, lexem *Lexem) error {\n   var itype int\n   prev := (*buf)[len(*buf)-2]\n   fblock := (*buf)[len(*buf)-1]\n   name := lexem.Value.(string)\n   switch state {\n      case stateBlock:\n         itype = ObjContract\n         name = StateName((*buf)[0].Info.(uint32), name)\n         fblock.Info = &ContractInfo{ID: uint32(len(prev.Children) - 1), Name: name,\n         Owner: (*buf)[0].Owner}\n      default:\n         itype = ObjFunc\n         fblock.Info = &FuncInfo{}\n   }\n   fblock.Type = itype\n   prev.Objects[name] = &ObjInfo{Type: itype, Value: fblock}\n   return nil\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Pour la fonction ",(0,r.jsx)(n.strong,{children:"CompileBlock"}),", elle parcourt simplement tous les jetons et\nchange d'\xe9tat en fonction des jetons d\xe9crits dans les \xe9tats. Presque tous les\njetons suppl\xe9mentaires correspondent \xe0 des codes de programme suppl\xe9mentaires."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"statePush"})," - ajoute l'objet ",(0,r.jsx)(n.strong,{children:"Block"})," \xe0 l'arbre d'objets;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"statePop"})," - utilis\xe9 lorsque le bloc se termine par une accolade fermante;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"stateStay"})," - vous devez conserver la marque actuelle lors du passage \xe0 un\nnouvel \xe9tat;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"stateToBlock"})," - transition vers l'\xe9tat ",(0,r.jsx)(n.strong,{children:"stateBlock"})," pour traiter les\ninstructions ",(0,r.jsx)(n.em,{children:"while"})," et ",(0,r.jsx)(n.em,{children:"if"}),". Apr\xe8s le traitement des expressions, vous devez\ntraiter les blocs \xe0 l'int\xe9rieur des accolades;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"stateToBody"})," - transition vers l'\xe9tat ",(0,r.jsx)(n.strong,{children:"stateBody"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"stateFork"})," - enregistre la position marqu\xe9e. Lorsque l'expression commence\npar un identifiant ou un nom avec ",(0,r.jsx)(n.code,{children:"$"}),", nous pouvons effectuer des appels de\nfonction ou des affectations;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"stateToFork"})," - utilis\xe9 pour obtenir le jeton stock\xe9 dans ",(0,r.jsx)(n.strong,{children:"stateFork"}),", qui\nsera transmis \xe0 la fonction de traitement;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"stateLabel"})," - utilis\xe9 pour ins\xe9rer des commandes ",(0,r.jsx)(n.strong,{children:"cmdLabel"}),". La structure\n",(0,r.jsx)(n.em,{children:"while"})," n\xe9cessite ce drapeau;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"stateMustEval"})," - v\xe9rifie la disponibilit\xe9 des expressions conditionnelles\nau d\xe9but des structures ",(0,r.jsx)(n.em,{children:"if"})," et ",(0,r.jsx)(n.em,{children:"while"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["En plus de la fonction ",(0,r.jsx)(n.strong,{children:"CompileBlock"}),", la fonction ",(0,r.jsx)(n.strong,{children:"FlushBlock"})," devrait\n\xe9galement \xeatre mentionn\xe9e. Mais le probl\xe8me est que l'arbre de blocs est\nconstruit ind\xe9pendamment des machines virtuelles existantes. Plus pr\xe9cis\xe9ment,\nnous obtenons des informations sur les fonctions et les contrats qui existent\ndans une machine virtuelle, mais nous collectons les blocs compil\xe9s dans un\narbre s\xe9par\xe9. Sinon, en cas d'erreur lors de la compilation, nous devons revenir\n\xe0 l'\xe9tat pr\xe9c\xe9dent de la machine virtuelle. Par cons\xe9quent, nous acc\xe9dons \xe0\nl'arbre de compilation s\xe9par\xe9ment, mais apr\xe8s que la compilation a r\xe9ussi, la\nfonction ",(0,r.jsx)(n.strong,{children:"FlushContract"})," doit \xeatre appel\xe9e. Cette fonction ajoute l'arbre de\nblocs termin\xe9 \xe0 la machine virtuelle actuelle. La phase de compilation est\nmaintenant termin\xe9e."]}),"\n",(0,r.jsx)(n.h2,{id:"lexical-analyzer",children:"Analyseur lexical"}),"\n",(0,r.jsx)(n.p,{children:"L'analyseur lexical traite les cha\xeenes entrantes et forme une s\xe9quence de jetons\ndes types suivants :"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexSys"})," - jeton syst\xe8me, par exemple : ",(0,r.jsx)(n.code,{children:"{}, [], (), ,, ."})," etc ;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexOper"})," - jeton d'op\xe9ration, par exemple : ",(0,r.jsx)(n.code,{children:"+, -, /, \\, *"})," ;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexNumber"})," - nombre ;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexident"})," - identifiant ;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexNewline"})," - caract\xe8re de saut de ligne ;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexString"})," - cha\xeene de caract\xe8res ;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexComment"})," - commentaire ;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexKeyword"})," - mot-cl\xe9 ;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexType"})," - type ;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexExtend"})," - r\xe9f\xe9rence \xe0 des variables ou fonctions externes, par exemple :\n",(0,r.jsx)(n.code,{children:"$myname"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Dans la version actuelle, une table de conversion (machine \xe0 \xe9tats finis) est\ninitialement construite \xe0 l'aide du fichier ",(0,r.jsx)(n.a,{href:"#lextable-lextable-go",children:"lextable.go"}),"\npour analyser les jetons, qui est ensuite \xe9crit dans le fichier lex_table.go. En\ng\xe9n\xe9ral, vous pouvez vous d\xe9barrasser de la table de conversion g\xe9n\xe9r\xe9e\ninitialement par le fichier et cr\xe9er une table de conversion en m\xe9moire\n(",(0,r.jsx)(n.code,{children:"init()"}),") imm\xe9diatement au d\xe9marrage. L'analyse lexicale elle-m\xeame se produit\ndans la fonction lexParser du fichier ",(0,r.jsx)(n.a,{href:"#lex-go",children:"lex.go"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"lextable-lextable-go",children:"lextable/lextable.go"}),"\n",(0,r.jsx)(n.p,{children:"Ici, nous d\xe9finissons l'alphabet sur lequel nous op\xe9rons et d\xe9crivons comment la\nmachine \xe0 \xe9tats finis change d'un \xe9tat \xe0 un autre en fonction du symbole suivant\nre\xe7u."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"states"})," est un objet JSON contenant une liste d'\xe9tats."]}),"\n",(0,r.jsxs)(n.p,{children:["Sauf pour des symboles sp\xe9cifiques, ",(0,r.jsx)(n.code,{children:"d"})," repr\xe9sente tous les symboles non\nsp\xe9cifi\xe9s dans l'\xe9tat. ",(0,r.jsx)(n.code,{children:"n"})," repr\xe9sente 0x0a, ",(0,r.jsx)(n.code,{children:"s"})," repr\xe9sente un espace, ",(0,r.jsx)(n.code,{children:"q"}),"\nrepr\xe9sente une apostrophe invers\xe9e, ",(0,r.jsx)(n.code,{children:"Q"})," repr\xe9sente des guillemets doubles, ",(0,r.jsx)(n.code,{children:"r"}),"\nrepr\xe9sente un caract\xe8re >= 128, ",(0,r.jsx)(n.code,{children:"a"})," repr\xe9sente AZ et az, et ",(0,r.jsx)(n.code,{children:"1"})," repr\xe9sente les\nchiffres de 1 \xe0 9."]}),"\n",(0,r.jsx)(n.p,{children:"Le nom de ces \xe9tats est une cl\xe9, et les valeurs possibles sont r\xe9pertori\xe9es dans\nl'objet valeur. Ensuite, il y a un nouvel \xe9tat pour effectuer des transitions\npour chaque groupe. Ensuite, il y a le nom du jeton. Si nous devons revenir \xe0\nl'\xe9tat initial, le troisi\xe8me param\xe8tre est le jeton de service, qui indique\ncomment traiter le symbole actuel."}),"\n",(0,r.jsxs)(n.p,{children:["Par exemple, nous avons l'\xe9tat principal et les caract\xe8res entrants ",(0,r.jsx)(n.code,{children:"/"}),",\n",(0,r.jsx)(n.code,{children:'"/": ["solidus", "", "push next"]'}),","]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"push"})," - donne la commande de se souvenir qu'il est dans une pile s\xe9par\xe9e ;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"next*"})," - passe au caract\xe8re suivant et en m\xeame temps nous changeons le\nstatut en ",(0,r.jsx)(n.strong,{children:"solidus"}),". Ensuite, obtient le caract\xe8re suivant et v\xe9rifie le\nstatut de ",(0,r.jsx)(n.strong,{children:"solidus"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Si le prochain caract\xe8re est ",(0,r.jsx)(n.code,{children:"/"})," ou ",(0,r.jsx)(n.code,{children:"/*"}),", alors nous passons \xe0 l'\xe9tat de\ncommentaire ",(0,r.jsx)(n.strong,{children:"comment"})," car ils commencent par ",(0,r.jsx)(n.code,{children:"//"})," ou ",(0,r.jsx)(n.code,{children:"/*"}),". \xc9videmment, chaque\ncommentaire a un \xe9tat diff\xe9rent par la suite, car ils se terminent par un\nsymbole diff\xe9rent."]}),"\n",(0,r.jsxs)(n.p,{children:["Si le prochain caract\xe8re n'est pas ",(0,r.jsx)(n.code,{children:"/"})," et ",(0,r.jsx)(n.code,{children:"*"}),", alors nous enregistrons tout dans\nla pile en tant que balises de type ",(0,r.jsx)(n.strong,{children:"lexOper"}),", nous vidons la pile et revenons\n\xe0 l'\xe9tat principal."]}),"\n",(0,r.jsxs)(n.p,{children:["Le module suivant convertit l'arbre d'\xe9tat en un tableau num\xe9rique et l'\xe9crit\ndans le fichier ",(0,r.jsx)(n.em,{children:"lex_table.go"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"Dans la premi\xe8re boucle :"}),"\n",(0,r.jsx)(n.p,{children:"Nous formons un alphabet de symboles valides."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"for ind, ch := range alphabet {\n   i := byte(ind)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["De plus, dans ",(0,r.jsx)(n.strong,{children:"state2int"}),", nous attribuons \xe0 chaque \xe9tat un identifiant de\ns\xe9quence propre."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"   state2int := map[string]uint{`main`: 0}\n   if err := json.Unmarshal([]byte(states), &data); err == nil {\n   for key := range data {\n   if key != `main` {\n   state2int[key] = uint(len(state2int))\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Lorsque nous parcourons tous les \xe9tats, chaque ensemble dans un \xe9tat et chaque\nsymbole dans un ensemble, nous \xe9crivons un nombre de trois octets [identifiant\nnouvel \xe9tat (0 = principal)] + [type de jeton (0-pas de jeton)] + [jeton]. La\nbidimensionnalit\xe9 du tableau ",(0,r.jsx)(n.em,{children:"table"})," est qu'il est divis\xe9 en \xe9tats et 34\nsymboles d'entr\xe9e du tableau ",(0,r.jsx)(n.em,{children:"alphabet"}),", qui sont dispos\xe9s dans le m\xeame ordre."]}),"\n",(0,r.jsxs)(n.p,{children:["Nous sommes dans l'\xe9tat ",(0,r.jsx)(n.em,{children:"principal"})," sur la ligne z\xe9ro du tableau ",(0,r.jsx)(n.em,{children:"table"}),". Prenez\nle premier caract\xe8re, trouvez son index dans le tableau ",(0,r.jsx)(n.em,{children:"alphabet"})," et obtenez la\nvaleur de la colonne avec l'index donn\xe9. \xc0 partir de la valeur obtenue, nous\nrecevons le jeton dans le octet de poids faible. Si l'analyse est termin\xe9e, le\ndeuxi\xe8me octet indique le type de jeton re\xe7u. Dans le troisi\xe8me octet, nous\nrecevons l'index du prochain nouvel \xe9tat. Tout cela est d\xe9crit plus en d\xe9tail\ndans la fonction ",(0,r.jsx)(n.strong,{children:"lexParser"})," dans le fichier ",(0,r.jsx)(n.em,{children:"lex.go"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Si vous souhaitez ajouter de nouveaux caract\xe8res, vous devez les ajouter au\ntableau ",(0,r.jsx)(n.em,{children:"alphabet"})," et augmenter la quantit\xe9 de la constante ",(0,r.jsx)(n.em,{children:"AlphaSize"}),". Si vous\nsouhaitez ajouter une nouvelle combinaison de symboles, elle doit \xeatre d\xe9crite\ndans l'\xe9tat, similaire aux options existantes. Apr\xe8s l'op\xe9ration ci-dessus,\nex\xe9cutez le fichier ",(0,r.jsx)(n.em,{children:"lextable.go"})," pour mettre \xe0 jour le fichier ",(0,r.jsx)(n.em,{children:"lex_table.go"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"lex-go",children:"lex-go"}),"\n",(0,r.jsxs)(n.p,{children:["La fonction ",(0,r.jsx)(n.strong,{children:"lexParser"})," g\xe9n\xe8re directement une analyse lexicale et renvoie un\ntableau de balises re\xe7ues en fonction des cha\xeenes entrantes. Analysons la\nstructure des jetons."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"type Lexem struct {\n   Type  uint32 // Type of the lexem\n   Value interface{} // Value of lexem\n   Line  uint32 // Line of the lexem\n   Column uint32 // Position inside the line\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type"})," - type de jeton. Il a l'une des valeurs suivantes :\n",(0,r.jsx)(n.code,{children:"lexSys, lexOper, lexNumber, lexIdent, lexString, lexComment, lexKeyword, lexType, lexExtend"}),"\n;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Value"})," - valeur du jeton. Le type de valeur d\xe9pend du type de jeton.\nAnalysons cela plus en d\xe9tail :"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexSys"})," - comprend des crochets, des virgules, etc. Dans ce cas,\n",(0,r.jsx)(n.code,{children:"Type = ch << 8 | lexSys"}),", veuillez vous r\xe9f\xe9rer \xe0 la constante\n",(0,r.jsx)(n.code,{children:"isLPar ... isRBrack"}),", et sa valeur est un entier non sign\xe9 de 32 bits ;","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexOper"})," - la valeur repr\xe9sente une s\xe9quence de caract\xe8res \xe9quivalente\nsous forme de uint32. Voir les constantes ",(0,r.jsx)(n.code,{children:"isNot ... isOr"})," ;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexNumber"})," - les nombres sont stock\xe9s en tant que int64 ou float64. S'il\ny a un point d\xe9cimal, c'est un float64 ;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexIdent"})," - les identifiants sont stock\xe9s en tant que cha\xeene de\ncaract\xe8res ;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexNewLine"})," - caract\xe8re de saut de ligne. Utilis\xe9 \xe9galement pour calculer\nla ligne et la position du jeton ;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexString"})," - les lignes sont stock\xe9es en tant que cha\xeene de caract\xe8res ;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexComment"})," - les commentaires sont stock\xe9s en tant que cha\xeene de\ncaract\xe8res ;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexKeyword"})," - pour les mots-cl\xe9s, seuls les index correspondants sont\nstock\xe9s, voir la constante ",(0,r.jsx)(n.code,{children:"keyContract ... keyTail"}),". Dans ce cas,\n",(0,r.jsx)(n.code,{children:"Type = KeyID << 8 | lexKeyword"}),". De plus, il convient de noter que les\nmots-cl\xe9s ",(0,r.jsx)(n.code,{children:"true, false, nil"})," seront imm\xe9diatement convertis en jetons de\ntype lexNumber, et les types correspondants ",(0,r.jsx)(n.code,{children:"bool"})," et ",(0,r.jsx)(n.code,{children:"intreface {}"})," seront\nutilis\xe9s ;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexType"})," - cette valeur contient la valeur de type ",(0,r.jsx)(n.code,{children:"reflect.Type"}),"\ncorrespondante ;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexExtend"})," - identifiants commen\xe7ant par un ",(0,r.jsx)(n.code,{children:"$"}),". Ces variables et\nfonctions sont transmises de l'ext\xe9rieur et sont donc attribu\xe9es \xe0 des types\nde jetons sp\xe9ciaux. Cette valeur contient le nom en tant que cha\xeene de\ncaract\xe8res sans le $ au d\xe9but."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Line"})," - la ligne o\xf9 se trouve le jeton ;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Column"})," - la position dans la ligne du jeton."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Analysons en d\xe9tail la fonction ",(0,r.jsx)(n.strong,{children:"lexParser"}),". La fonction ",(0,r.jsx)(n.strong,{children:"todo"})," recherche\nl'index du symbole dans l'alphabet en fonction de l'\xe9tat actuel et du symbole\nentrant, et obtient un nouvel \xe9tat, un identifiant de jeton (le cas \xe9ch\xe9ant) et\nd'autres jetons \xe0 partir de la table de conversion. L'analyse elle-m\xeame consiste\n\xe0 appeler la fonction ",(0,r.jsx)(n.strong,{children:"todo"})," successivement pour chaque caract\xe8re suivant et \xe0\npasser \xe0 un nouvel \xe9tat. Une fois que la balise est re\xe7ue, nous cr\xe9ons le jeton\ncorrespondant dans le crit\xe8re de sortie et continuons le processus d'analyse. Il\nconvient de noter que pendant le processus d'analyse, nous n'accumulons pas les\nsymboles de jeton dans une pile ou un tableau s\xe9par\xe9, car nous ne sauvegardons\nque le d\xe9calage du d\xe9but du jeton. Apr\xe8s avoir obtenu le jeton, nous d\xe9pla\xe7ons\nle d\xe9calage du prochain jeton vers la position d'analyse actuelle."]}),"\n",(0,r.jsx)(n.p,{children:"Il ne reste plus qu'\xe0 v\xe9rifier les jetons d'\xe9tat lexical utilis\xe9s dans l'analyse\n:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexfPush"})," - ce jeton signifie que nous commen\xe7ons \xe0 accumuler des symboles\ndans un nouveau jeton ;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexfNext"})," - le caract\xe8re doit \xeatre ajout\xe9 au jeton actuel ;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexfPop"})," - la r\xe9ception du jeton est termin\xe9e. G\xe9n\xe9ralement, avec ce\ndrapeau, nous avons le type d'identifiant du jeton analys\xe9 ;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lexfSkip"})," - ce jeton est utilis\xe9 pour exclure des caract\xe8res de l'analyse.\nPar exemple, les barres obliques de contr\xf4le dans la cha\xeene sont \\n \\r \". Ils\nseront automatiquement remplac\xe9s lors de l'\xe9tape d'analyse lexicale."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"needle-language",children:"Langage Needle"}),"\n",(0,r.jsx)(n.h3,{id:"lexemes",children:"Lexemes"}),"\n",(0,r.jsx)(n.p,{children:"Le code source d'un programme doit \xeatre encod\xe9 en UTF-8."}),"\n",(0,r.jsx)(n.p,{children:"Les types lexicaux suivants sont trait\xe9s :"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Keywords"})," -\n",(0,r.jsx)(n.code,{children:"action, break, conditions, continue, contract, data, else, error, false, func, If, info, nil, return, settings, true, var, warning, while"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Number"})," - seuls les nombres d\xe9cimaux sont accept\xe9s. Il existe deux types de\nbase : ",(0,r.jsx)(n.strong,{children:"int"})," et ",(0,r.jsx)(n.strong,{children:"float"}),". Si le nombre comporte un point d\xe9cimal, il\ndevient un ",(0,r.jsx)(n.strong,{children:"float"}),". Le type ",(0,r.jsx)(n.strong,{children:"int"})," est \xe9quivalent \xe0 ",(0,r.jsx)(n.strong,{children:"int64"})," en golang,\ntandis que le type ",(0,r.jsx)(n.strong,{children:"float"})," est \xe9quivalent \xe0 ",(0,r.jsx)(n.strong,{children:"float64"})," en golang."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"String"})," - la cha\xeene de caract\xe8res peut \xeatre encadr\xe9e par des guillemets\ndoubles ",(0,r.jsx)(n.code,{children:'("une cha\xeene de caract\xe8res")'})," ou des guillemets invers\xe9s\n",(0,r.jsx)(n.code,{children:"(\\`une cha\xeene de caract\xe8res\\`)"}),". Les deux types de cha\xeenes peuvent contenir\ndes caract\xe8res de nouvelle ligne. Les cha\xeenes entre guillemets doubles peuvent\ncontenir des guillemets doubles, des caract\xe8res de nouvelle ligne et des\nretours chariot \xe9chapp\xe9s avec des barres obliques inverses. Par exemple,\n",(0,r.jsx)(n.code,{children:'"Ceci est une \\"premi\xe8re cha\xeene\\".\\r\\nCeci est une deuxi\xe8me cha\xeene."'}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Comment"})," - il existe deux types de commentaires. Les commentaires sur une\nseule ligne utilisent deux barres obliques (//). Par exemple, // Ceci est un\ncommentaire sur une seule ligne. Les commentaires sur plusieurs lignes\nutilisent le symbole barre oblique et ast\xe9risque et peuvent s'\xe9tendre sur\nplusieurs lignes. Par exemple,\n",(0,r.jsx)(n.code,{children:"/* Ceci est un commentaire sur plusieurs lignes */"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Identifier"})," - les noms de variables et de fonctions sont compos\xe9s de\nlettres a-z et A-Z, de symboles UTF-8, de chiffres et de traits de\nsoulignement. Le nom peut commencer par une lettre, un trait de soulignement,\n",(0,r.jsx)(n.code,{children:"@"})," ou ",(0,r.jsx)(n.code,{children:"$"}),". Le nom commen\xe7ant par ",(0,r.jsx)(n.code,{children:"$"})," est le nom de la variable d\xe9finie dans\nla ",(0,r.jsx)(n.strong,{children:"section data"}),". Le nom commen\xe7ant par ",(0,r.jsx)(n.code,{children:"$"})," peut \xe9galement \xeatre utilis\xe9\npour d\xe9finir des variables globales dans la port\xe9e des ",(0,r.jsx)(n.strong,{children:"sections conditions"}),"\net ",(0,r.jsx)(n.strong,{children:"action"}),". Les contrats de l'\xe9cosyst\xe8me peuvent \xeatre appel\xe9s \xe0 l'aide du\nsymbole ",(0,r.jsx)(n.code,{children:"@"}),". Par exemple : ",(0,r.jsx)(n.code,{children:"@1NouvelleTable(...)"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"types",children:"Types"}),"\n",(0,r.jsx)(n.p,{children:"Les types correspondants en golang sont sp\xe9cifi\xe9s \xe0 c\xf4t\xe9 des types Needle."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"bool"})," - bool, ",(0,r.jsx)(n.strong,{children:"false"})," by default;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"bytes"})," - []byte",", un tableau vide de bytes par d\xe9faut;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"int"})," - int64, ",(0,r.jsx)(n.strong,{children:"0"})," par d\xe9faut;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"address"})," - uint64, ",(0,r.jsx)(n.strong,{children:"0"})," par d\xe9faut;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"array"})," - []interface",", un tableau vide par d\xe9faut;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"map"})," - map[string]interface",", un objet vide par d\xe9faut;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"money"})," - decimal. Decimal, ",(0,r.jsx)(n.strong,{children:"0"})," par d\xe9faut;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"float"})," - float64, ",(0,r.jsx)(n.strong,{children:"0"})," par d\xe9faut;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"string"})," - string, une cha\xeene vide par d\xe9faut;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"file"})," - map[string]interface",", un objet vide par d\xe9faut."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Ces types de variables sont d\xe9finis avec le mot-cl\xe9 ",(0,r.jsx)(n.code,{children:"var"}),". Par exemple,\n",(0,r.jsx)(n.code,{children:"var var1, var2 int"}),". Lorsqu'ils sont d\xe9finis de cette mani\xe8re, une variable\nsera affect\xe9e \xe0 une valeur par d\xe9faut selon son type."]}),"\n",(0,r.jsxs)(n.p,{children:["Toutes les valeurs des variables sont de type interface",", puis elles sont\naffect\xe9es aux types golang requis. Par cons\xe9quent, par exemple, les types array\net map sont les types golang []interface"," et map[string]interface",". Les deux\ntypes de tableaux peuvent contenir des \xe9l\xe9ments de n'importe quel type."]}),"\n",(0,r.jsx)(n.h3,{id:"expressions",children:"Expressions"}),"\n",(0,r.jsx)(n.p,{children:"Une expression peut inclure des op\xe9rations arithm\xe9tiques, des op\xe9rations\nlogiques et des appels de fonctions. Toutes les expressions sont \xe9valu\xe9es de\ngauche \xe0 droite en fonction de la priorit\xe9 des op\xe9rateurs. En cas de priorit\xe9\n\xe9gale, les op\xe9rateurs sont \xe9valu\xe9s de gauche \xe0 droite."}),"\n",(0,r.jsx)(n.p,{children:"Priorit\xe9 des op\xe9rations de haut en bas :"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Appel de fonction et parenth\xe8ses"})," - lorsqu'une fonction est appel\xe9e, les\nparam\xe8tres pass\xe9s sont calcul\xe9s de gauche \xe0 droite ;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Op\xe9ration unaire"})," - n\xe9gation logique ",(0,r.jsx)(n.code,{children:"!"})," et changement de signe\narithm\xe9tique ",(0,r.jsx)(n.code,{children:"-"})," ;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Multiplication et Division"})," - multiplication arithm\xe9tique ",(0,r.jsx)(n.code,{children:"*"})," et division\n",(0,r.jsx)(n.code,{children:"/"})," ;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Addition et Soustraction"})," - addition arithm\xe9tique ",(0,r.jsx)(n.code,{children:"+"})," et soustraction ",(0,r.jsx)(n.code,{children:"-"})," ;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Comparaison logique"})," - ",(0,r.jsx)(n.code,{children:">=>> >="})," ;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"\xc9galit\xe9 et in\xe9galit\xe9 logiques"})," - ",(0,r.jsx)(n.code,{children:"== !="})," ;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ET logique"})," - ",(0,r.jsx)(n.code,{children:"&&"})," ;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"OU logique"})," - ",(0,r.jsx)(n.code,{children:"||"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Lors de l'\xe9valuation des op\xe9rateurs logiques ET et OU, les deux c\xf4t\xe9s de\nl'expression sont \xe9valu\xe9s dans tous les cas."}),"\n",(0,r.jsxs)(n.p,{children:["Needle ne v\xe9rifie pas les types lors de la compilation. Lors de l'\xe9valuation des\nop\xe9randes, une tentative est faite pour convertir le type en un type plus\ncomplexe. L'ordre de complexit\xe9 des types peut \xeatre le suivant :\n",(0,r.jsx)(n.code,{children:"string, int, float, money"}),". Seules certaines conversions de types sont\nimpl\xe9ment\xe9es. Le type string prend en charge les op\xe9rations d'addition, et le\nr\xe9sultat sera une concat\xe9nation de cha\xeenes de caract\xe8res. Par exemple,\n",(0,r.jsx)(n.code,{children:"string + string = string, money-int = money, int * float = float"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Pour les fonctions, une v\xe9rification des types est effectu\xe9e sur les types\n",(0,r.jsx)(n.code,{children:"string"})," et ",(0,r.jsx)(n.code,{children:"int"})," lors de l'ex\xe9cution."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"array"})," et ",(0,r.jsx)(n.strong,{children:"map"})," types peuvent \xeatre adress\xe9s par index. Pour le type\n",(0,r.jsx)(n.strong,{children:"array"}),", la valeur ",(0,r.jsx)(n.strong,{children:"int"})," doit \xeatre sp\xe9cifi\xe9e comme index. Pour le type\n",(0,r.jsx)(n.strong,{children:"map"}),", une variable ou une valeur ",(0,r.jsx)(n.strong,{children:"string"})," doit \xeatre sp\xe9cifi\xe9e. Si vous\nassignez une valeur \xe0 un \xe9l\xe9ment de l'",(0,r.jsx)(n.strong,{children:"array"})," dont l'index est sup\xe9rieur \xe0\nl'index maximum actuel, un \xe9l\xe9ment vide sera ajout\xe9 \xe0 l'array. La valeur\ninitiale de ces \xe9l\xe9ments est ",(0,r.jsx)(n.strong,{children:"nil"}),". Par exemple: .. code:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'var my array\nmy[5] = 0\nvar mymap map\nmymap["index"] = my[3]\n'})}),"\n",(0,r.jsxs)(n.p,{children:["In expressions of conditional logical values (such as ",(0,r.jsx)(n.code,{children:"if, while, &&, ||, !"}),"),\nthe type is automatically converted to a logical value. If the type is not the\ndefault value, it is true."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"var mymap map\nvar val string\nif mymap && val {\n...\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"scope",children:"Port\xe9e"}),"\n",(0,r.jsx)(n.p,{children:"Les accolades sp\xe9cifient un bloc qui peut contenir des variables \xe0 port\xe9e\nlocale. Par d\xe9faut, la port\xe9e d'une variable s'\xe9tend \xe0 ses propres blocs et \xe0\ntous les blocs imbriqu\xe9s. Dans un bloc, vous pouvez d\xe9finir une nouvelle\nvariable en utilisant le nom d'une variable existante. Cependant, dans ce cas,\nles variables externes portant le m\xeame nom deviennent indisponibles."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"var a int\na = 3\n{\n   var a int\n   a = 4\n   Println(a) // 4\n}\nPrintln(a) // 3\n"})}),"\n",(0,r.jsx)(n.h3,{id:"contract-execution",children:"Ex\xe9cution de contrat intelligent"}),"\n",(0,r.jsxs)(n.p,{children:["Lors de l'appel d'un contrat intelligent, les param\xe8tres d\xe9finis dans ",(0,r.jsx)(n.strong,{children:"data"}),"\ndoivent lui \xeatre transmis. Avant d'ex\xe9cuter un contrat, la machine virtuelle\nre\xe7oit ces param\xe8tres et les assigne aux variables correspondantes ($Param).\nEnsuite, la fonction pr\xe9d\xe9finie ",(0,r.jsx)(n.strong,{children:"conditions"})," et la fonction ",(0,r.jsx)(n.strong,{children:"action"})," sont\nappel\xe9es."]}),"\n",(0,r.jsxs)(n.p,{children:["Les erreurs survenant lors de l'ex\xe9cution d'un contrat peuvent \xeatre divis\xe9es en\ndeux types : les erreurs de formulaire et les erreurs d'environnement. Les\nerreurs de formulaire sont g\xe9n\xe9r\xe9es \xe0 l'aide de commandes sp\xe9ciales :\n",(0,r.jsx)(n.code,{children:"error, warning, info"})," et lorsque la fonction int\xe9gr\xe9e renvoie ",(0,r.jsx)(n.code,{children:"err"})," diff\xe9rent\nde ",(0,r.jsx)(n.em,{children:"nil"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"Le langage Needle ne g\xe8re pas les exceptions. Toute erreur mettra fin \xe0\nl'ex\xe9cution des contrats. \xc9tant donn\xe9 qu'une pile s\xe9par\xe9e et une structure pour\nsauvegarder les valeurs des variables sont cr\xe9\xe9es lors de l'ex\xe9cution d'un\ncontrat, le m\xe9canisme de collecte des d\xe9chets de golang supprimera\nautomatiquement ces donn\xe9es lors de l'ex\xe9cution d'un contrat."}),"\n",(0,r.jsx)(n.h3,{id:"backus-naur-form-bnf",children:"Forme de Backus-Naur (BNF)"}),"\n",(0,r.jsx)(n.p,{children:"En informatique, BNF est une technique de notation pour la syntaxe sans contexte\net est g\xe9n\xe9ralement utilis\xe9e pour d\xe9crire la syntaxe du langage utilis\xe9 en\ninformatique."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<decimal digit>"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<decimal number>"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"<decimal digit> {<decimal digit>}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<symbol code>"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'''<any symbol>'''\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<real number>"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"['-'] <decimal number'.'[<decimal number>]\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<integer number>"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"['-'] <decimal number> | <symbol code>\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<number>"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'<integer number> | <real number>'\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<letter>"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'A' |'B' | ... |'Z' |'a' |'b' | ... |'z' | 0x80 | 0x81 | ... | 0xFF\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<space>"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'0x20'\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<tabulation>"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'0x09'\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<newline>"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'0x0D 0x0A'\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<special symbol>"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'!' |'\"' |'$' |''' |'(' |')' |'\\*' |'+' |',' |'-' |'.' |'/ '|'<' |'=' |'>' |'[' |'\\\\' |']' |'_' |'|' |'}' | '{' | <tabulation> | <space> | <newline>\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<symbol>"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"<decimal digit> | <letter> | <special symbol>\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<name>"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"(<letter> |'_') {<letter> |'_' | <decimal digit>}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<function name>"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"<name>\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<variable name>"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"<name>\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<type name>"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"<name>\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<string symbol>"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"<tabulation> | <space> |'!' |'#' | ... |'[' |']' | ...\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<string element>"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"{<string symbol> |'\\\"' |'\\n' |'\\r'}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<string>"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'\"' {<string element>}'\"' |'\\`' {<string element>}'\\`'\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<assignment operator>"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'='\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<unary operator>"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'-'\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<binary operator>"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'==' |'!=' |'>' |'<' |'<=' |'>=' |'&&' |'||' |'\\*' |'/' |'+ '|'-'\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<operator>"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"<assignment operator> | <unary operator> | <binary operator>\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<parameters>"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"<expression> {','<expression>}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<contract call>"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"<contract name>'(' [<parameters>]')'\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<function call>"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"<contract call> [{'.' <name>'(' [<parameters>]')'}]\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<block contents>"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"<block command> {<newline><block command>}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<block>"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'{'<block contents>'}'\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<block command>"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"(<block> | <expression> | <variables definition> | <if> | <while> | break | continue | return)\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<if>"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'if <expression><block> [else <block>]'\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<while>"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'while <expression><block>'\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<contract>"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'contract <name> '{'[<data section>] {<function>} [<conditions>] [<action>]'}''\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<data section>"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'data '{' {<data parameter><newline>} '}''\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<data parameter>"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"<variable name> <type name>'\"'{<tag>}'\"'\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<tag>"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'optional | image | file | hidden | text | polymap | map | address | signature:<name>'\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<conditions>"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'conditions <block>'\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<action>"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'action <block>'\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<function>"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'func <function name>'('[<variable description>{','<variable description>}]')'[{<tail>}] [<type name>] <block>'\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<variable description>"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"<variable name> {',' <variable name>} <type name>\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<tail>"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'.'<function name>'('[<variable description>{','<variable description>}]')'\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<variables definition>"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'var <variable description>{','<variable description>}'\n"})})]})}function x(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},4252:(e,n,s)=>{s.d(n,{A:()=>i});s(6540);var r=s(5195);const l={tableOfContentsInline:"tableOfContentsInline_prmo"};var t=s(4848);function i(e){let{toc:n,minHeadingLevel:s,maxHeadingLevel:i}=e;return(0,t.jsx)("div",{className:l.tableOfContentsInline,children:(0,t.jsx)(r.A,{toc:n,minHeadingLevel:s,maxHeadingLevel:i,className:"table-of-contents",linkClassName:null})})}},5195:(e,n,s)=>{s.d(n,{A:()=>j});var r=s(6540),l=s(6342);function t(e){const n=e.map((e=>({...e,parentIndex:-1,children:[]}))),s=Array(7).fill(-1);n.forEach(((e,n)=>{const r=s.slice(2,e.level);e.parentIndex=Math.max(...r),s[e.level]=n}));const r=[];return n.forEach((e=>{const{parentIndex:s,...l}=e;s>=0?n[s].children.push(l):r.push(l)})),r}function i(e){let{toc:n,minHeadingLevel:s,maxHeadingLevel:r}=e;return n.flatMap((e=>{const n=i({toc:e.children,minHeadingLevel:s,maxHeadingLevel:r});return function(e){return e.level>=s&&e.level<=r}(e)?[{...e,children:n}]:n}))}function c(e){const n=e.getBoundingClientRect();return n.top===n.bottom?c(e.parentNode):n}function o(e,n){let{anchorTopOffset:s}=n;const r=e.find((e=>c(e).top>=s));if(r){return function(e){return e.top>0&&e.bottom<window.innerHeight/2}(c(r))?r:e[e.indexOf(r)-1]??null}return e[e.length-1]??null}function a(){const e=(0,r.useRef)(0),{navbar:{hideOnScroll:n}}=(0,l.p)();return(0,r.useEffect)((()=>{e.current=n?0:document.querySelector(".navbar").clientHeight}),[n]),e}function d(e){const n=(0,r.useRef)(void 0),s=a();(0,r.useEffect)((()=>{if(!e)return()=>{};const{linkClassName:r,linkActiveClassName:l,minHeadingLevel:t,maxHeadingLevel:i}=e;function c(){const e=function(e){return Array.from(document.getElementsByClassName(e))}(r),c=function(e){let{minHeadingLevel:n,maxHeadingLevel:s}=e;const r=[];for(let l=n;l<=s;l+=1)r.push(`h${l}.anchor`);return Array.from(document.querySelectorAll(r.join()))}({minHeadingLevel:t,maxHeadingLevel:i}),a=o(c,{anchorTopOffset:s.current}),d=e.find((e=>a&&a.id===function(e){return decodeURIComponent(e.href.substring(e.href.indexOf("#")+1))}(e)));e.forEach((e=>{!function(e,s){s?(n.current&&n.current!==e&&n.current.classList.remove(l),e.classList.add(l),n.current=e):e.classList.remove(l)}(e,e===d)}))}return document.addEventListener("scroll",c),document.addEventListener("resize",c),c(),()=>{document.removeEventListener("scroll",c),document.removeEventListener("resize",c)}}),[e,s])}var u=s(8774),x=s(4848);function h(e){let{toc:n,className:s,linkClassName:r,isChild:l}=e;return n.length?(0,x.jsx)("ul",{className:l?void 0:s,children:n.map((e=>(0,x.jsxs)("li",{children:[(0,x.jsx)(u.A,{to:`#${e.id}`,className:r??void 0,dangerouslySetInnerHTML:{__html:e.value}}),(0,x.jsx)(h,{isChild:!0,toc:e.children,className:s,linkClassName:r})]},e.id)))}):null}const p=r.memo(h);function j(e){let{toc:n,className:s="table-of-contents table-of-contents__left-border",linkClassName:c="table-of-contents__link",linkActiveClassName:o,minHeadingLevel:a,maxHeadingLevel:u,...h}=e;const j=(0,l.p)(),m=a??j.tableOfContents.minHeadingLevel,f=u??j.tableOfContents.maxHeadingLevel,v=function(e){let{toc:n,minHeadingLevel:s,maxHeadingLevel:l}=e;return(0,r.useMemo)((()=>i({toc:t(n),minHeadingLevel:s,maxHeadingLevel:l})),[n,s,l])}({toc:n,minHeadingLevel:m,maxHeadingLevel:f});return d((0,r.useMemo)((()=>{if(c&&o)return{linkClassName:c,linkActiveClassName:o,minHeadingLevel:m,maxHeadingLevel:f}}),[c,o,m,f])),(0,x.jsx)(p,{toc:v,className:s,linkClassName:c,...h})}},8453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>c});var r=s(6540);const l={},t=r.createContext(l);function i(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:i(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);